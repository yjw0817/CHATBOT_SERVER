{% extends "base.html" %}

{% block content %}
<section class="upload-section">
    <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:0.5rem;">
        <h2 style="margin:0;">ğŸ“¤ ë¬¸ì„œ ì—…ë¡œë“œ & ë§¤ë‰´ì–¼í™”</h2>
        <div style="display:flex;align-items:center;gap:0.5rem;font-size:13px;">
            <span style="color:#6b7280;">LLM:</span>
            <button id="main-btn-local" class="btn-small" onclick="switchLlmMode('local')" style="padding:3px 10px;border-radius:12px;font-size:12px;border:1px solid #d1d5db;background:#fff;color:#374151;cursor:pointer;">Local</button>
            <button id="main-btn-remote" class="btn-small" onclick="switchLlmMode('remote')" style="padding:3px 10px;border-radius:12px;font-size:12px;border:1px solid #d1d5db;background:#fff;color:#374151;cursor:pointer;">Remote</button>
            <select id="main-model-select" style="padding:2px 6px;border-radius:12px;font-size:12px;border:1px solid #d1d5db;background:#fff;color:#374151;cursor:pointer;">
                <option value="">ëª¨ë¸ ë¡œë”©...</option>
            </select>
            <span id="main-mode-info" style="color:#9ca3af;font-size:11px;"></span>
        </div>
    </div>

    <!-- Create Apartment -->
    <div class="card">
        <h3>ì•„íŒŒíŠ¸ ì¶”ê°€</h3>
        <form id="apt-form" hx-post="/api/apartments" hx-swap="none"
            hx-on::after-request="if(event.detail.successful) { this.reset(); location.reload(); }">
            <input type="text" name="apt_id" placeholder="ì•„íŒŒíŠ¸ ID (ì˜ˆ: APT001)" required>
            <input type="text" name="name" placeholder="ì•„íŒŒíŠ¸ ì´ë¦„" required>
            <button type="submit">â• ì¶”ê°€</button>
        </form>
    </div>

    <!-- Apartment List -->
    <div class="card">
        <h3>ë“±ë¡ëœ ì•„íŒŒíŠ¸</h3>
        {% if apartments %}
        <ul style="list-style:none;padding:0;margin:0;">
            {% for apt in apartments %}
            <li style="display:flex;justify-content:space-between;align-items:center;padding:6px 0;border-bottom:1px solid #eee;">
                <span>{{ apt.name }} ({{ apt.apt_id }})</span>
                <button class="btn-small" style="background:#f87171;color:white;" onclick="deleteApartment('{{ apt.apt_id }}', '{{ apt.name }}')">ğŸ—‘ï¸ ì‚­ì œ</button>
            </li>
            {% endfor %}
        </ul>
        {% else %}
        <p class="text-muted">ë“±ë¡ëœ ì•„íŒŒíŠ¸ê°€ ì—†ìŠµë‹ˆë‹¤.</p>
        {% endif %}
    </div>

    <!-- Upload Document -->
    <div class="card">
        <h3>ë¬¸ì„œ ì—…ë¡œë“œ</h3>
        <form id="upload-form" hx-post="/api/upload" hx-encoding="multipart/form-data" hx-swap="none"
            hx-on::after-request="if(event.detail.successful) location.reload();">
            <select name="apt_id" required>
                <option value="">-- ì•„íŒŒíŠ¸ ì„ íƒ --</option>
                {% for apt in apartments %}
                <option value="{{ apt.apt_id }}">{{ apt.name }} ({{ apt.apt_id }})</option>
                {% endfor %}
            </select>
            <input type="file" name="file" accept=".docx,.pdf,.txt,.md" required>
            <button type="submit">ğŸ“ ì—…ë¡œë“œ</button>
        </form>
    </div>
</section>

<section class="doc-list">
    <h2>ğŸ“‹ ë¬¸ì„œ ëª©ë¡</h2>
    <table>
        <thead>
            <tr>
                <th>ì•„íŒŒíŠ¸</th>
                <th>ë¬¸ì„œëª…</th>
                <th>ë²„ì „</th>
                <th>ìƒíƒœ</th>
                <th>ì—…ë¡œë“œì¼</th>
                <th>ì‘ì—…</th>
            </tr>
        </thead>
        <tbody>
            {% for doc in documents %}
            <tr class="status-{{ doc.status|lower }}" id="row-{{ doc.doc_id }}">
                <td>{{ doc.apt_name or doc.apt_id }}</td>
                <td>{{ doc.title }}</td>
                <td>v{{ doc.version }}</td>
                <td>
                    <span class="badge badge-{{ doc.status|lower }}">{{ doc.status }}</span>
                    {% if doc.has_rag %}<span class="rag-check" title="RAG ë°ì´í„°í™” ì™„ë£Œ">&#10003;</span>{% endif %}
                </td>
                <td>{{ doc.created_at.strftime('%Y-%m-%d %H:%M') if doc.created_at else '' }}</td>
                <td class="actions-cell">
                    {% if doc.status != 'ARCHIVED' %}
                    <button class="btn-small btn-extract" onclick="extractText('{{ doc.doc_id }}')">ğŸ“„ Extract</button>
                    {% if doc.has_manual %}
                    <button class="btn-small btn-view-manual" onclick="openEditor('{{ doc.doc_id }}')">ğŸ“– ë§¤ë‰´ì–¼
                        ë³´ê¸°</button>
                    {% else %}
                    <button class="btn-small btn-manualize" onclick="manualize('{{ doc.doc_id }}')">ğŸ“
                        Manualize</button>
                    {% endif %}
                    <button class="btn-small btn-approve" id="approve-btn-{{ doc.doc_id }}"
                        onclick="approve('{{ doc.doc_id }}')"
                        {% if not doc.has_pass %}disabled style="opacity:0.4;cursor:not-allowed;"{% endif %}>âš™ï¸ RAG ë°ì´í„°í™”</button>
                    <button class="btn-small" style="background:#f87171;color:white;" onclick="deleteDocument('{{ doc.doc_id }}', '{{ doc.title }}')">ğŸ—‘ï¸</button>
                    {% else %}
                    <span class="text-muted">Archived</span>
                    {% endif %}
                </td>
            </tr>
            {% else %}
            <tr>
                <td colspan="6" class="empty">ì—…ë¡œë“œëœ ë¬¸ì„œê°€ ì—†ìŠµë‹ˆë‹¤.</td>
            </tr>
            {% endfor %}
        </tbody>
    </table>
</section>

<!-- Result Modal -->
<div id="result-modal" class="modal" style="display:none;">
    <div class="modal-content">
        <span class="close" onclick="closeModal()">&times;</span>
        <h3 id="modal-title">ê²°ê³¼</h3>
        <div id="modal-body"></div>
        <div id="modal-buttons" style="display:none;margin-top:1rem;display:flex;gap:0.5rem;justify-content:flex-end;">
        </div>
    </div>
</div>

<!-- Editor Modal -->
<div id="editor-modal" class="modal" style="display:none;">
    <div class="modal-content editor-modal-content" style="max-width: 1200px; width: 95%;">
        <div class="editor-header">
            <span class="close" onclick="closeEditor()">&times;</span>
            <div style="display:flex;align-items:center;gap:0.6rem;flex-wrap:wrap;">
                <h3 style="margin:0;">âœï¸ ë§¤ë‰´ì–¼ ì—ë””í„°</h3>
                <button id="btn-mode-local" class="btn-small" onclick="switchLlmMode('local')" style="padding:3px 10px;border-radius:12px;font-size:12px;border:1px solid #d1d5db;background:#fff;color:#374151;cursor:pointer;">Local</button>
                <button id="btn-mode-remote" class="btn-small" onclick="switchLlmMode('remote')" style="padding:3px 10px;border-radius:12px;font-size:12px;border:1px solid #d1d5db;background:#fff;color:#374151;cursor:pointer;">Remote</button>
                <select id="editor-model-select" style="padding:2px 6px;border-radius:12px;font-size:12px;border:1px solid #d1d5db;background:#fff;color:#374151;cursor:pointer;">
                    <option value="">ëª¨ë¸ ë¡œë”©...</option>
                </select>
                <span id="llm-mode-info" style="color:#9ca3af;font-size:10px;"></span>
                <span id="manualize-status" class="manualize-lamp" style="display:none;">Manualizing</span>
                <span id="manualize-timer" style="display:none;font-size:12px;color:#6b7280;font-variant-numeric:tabular-nums;">0.0s</span>
            </div>
            <p class="text-muted">ë‚´ìš©ì„ ì§ì ‘ ìˆ˜ì •í•˜ê±°ë‚˜ AIì˜ ë„ì›€ì„ ë°›ì•„ ë³´ê°•í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.</p>
        </div>

        <div id="editor-container" class="editor-body">
            <!-- Sections will be injected here -->
        </div>

        <div class="editor-footer">
            <button class="btn" style="background:#9ca3af;" onclick="closeEditor()">ì·¨ì†Œ</button>
            <button class="btn" style="background:#f59e0b;" onclick="manualize(currentDocId, true)">ğŸ”„ ë‹¤ì‹œ Manualize</button>
            <button id="btn-fill-all" class="btn" style="background:#10b981;" onclick="fillAll()">â‘  ë§¥ë½ ë³´ê°•(ì „ì²´)</button>
            <button id="btn-refine-all" class="btn" style="background:#6366f1;" onclick="refineAll()">â‘¡ RAG ìµœì í™”(ì „ì²´)</button>
            <button id="btn-gate-all" class="btn" style="background:#f59e0b;" onclick="gateAll()">â‘¢ Gate(ì „ì²´)</button>
            <button id="btn-publish-all" class="btn" style="background:#7c3aed;opacity:0.4;cursor:not-allowed;" onclick="publishAll()" disabled>ğŸ“¦ RAG ë°˜ì˜</button>
            <button id="save-editor-btn" class="btn" onclick="saveEditor()">ğŸ’¾ ì €ì¥í•˜ê¸°</button>
        </div>
    </div>
</div>

<!-- Comparison Modal -->
<div id="compare-modal" class="modal" style="display:none;">
    <div class="modal-content" style="max-width: 1100px; width: 95%;">
        <span class="close" onclick="closeCompare()">&times;</span>
        <h3 id="compare-title">ğŸ”„ AI ì œì•ˆ ë¹„êµ</h3>
        <p class="text-muted" style="margin-bottom:1rem;">ì™¼ìª½ì´ í˜„ì¬ ë‚´ìš©, ì˜¤ë¥¸ìª½ì´ AI ì œì•ˆì…ë‹ˆë‹¤. ì˜¤ë¥¸ìª½ì„ ìˆ˜ì •í•œ ë’¤ ì ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.</p>
        <div class="compare-container">
            <div class="compare-panel">
                <div class="compare-label">ğŸ“„ í˜„ì¬ (Before)</div>
                <div id="compare-before" class="compare-text"></div>
            </div>
            <div class="compare-panel">
                <div class="compare-label">âœ¨ AI ì œì•ˆ (After)</div>
                <textarea id="compare-after" class="compare-textarea"></textarea>
            </div>
        </div>
        <div style="margin-top: 1rem; display: flex; justify-content: flex-end; gap: 0.5rem;">
            <button class="btn" style="background:#9ca3af;" onclick="closeCompare()">âŒ ì·¨ì†Œ (ì›ë˜ ìœ ì§€)</button>
            <button class="btn" style="background:#6b7280;" onclick="applyCompareSaveOnly()">âœ… ì ìš©(ì €ì¥)</button>
            <button class="btn" style="background:#3b82f6;" onclick="applyCompareSaveAndGate()">âœ… ì ìš© + Gate ì¬ê²€ì¦</button>
        </div>
    </div>
</div>

<script>
    let currentDocId = null;

    // â”€â”€ LLM Controls (Main + Editor share mode/model) â”€â”€
    const EMBED_MODELS = ['bge-m3'];
    // All mode button pairs (main page + editor modal)
    const MODE_BTN_IDS = [
        { local: 'main-btn-local', remote: 'main-btn-remote', info: 'main-mode-info' },
        { local: 'btn-mode-local', remote: 'btn-mode-remote', info: 'llm-mode-info' }
    ];
    // All model select elements (main page + editor modal)
    const MODEL_SELECT_IDS = ['main-model-select', 'editor-model-select'];

    function updateModeUI(mode, info) {
        for (const ids of MODE_BTN_IDS) {
            const btnL = document.getElementById(ids.local);
            const btnR = document.getElementById(ids.remote);
            const infoEl = document.getElementById(ids.info);
            if (btnL && btnR) {
                const active = 'padding:3px 10px;border-radius:12px;font-size:12px;border:1px solid transparent;cursor:pointer;font-weight:700;';
                const inactive = 'padding:3px 10px;border-radius:12px;font-size:12px;border:1px solid #d1d5db;background:#fff;color:#374151;cursor:pointer;';
                if (mode === 'local') {
                    btnL.style.cssText = active + 'background:#10b981;color:white;';
                    btnR.style.cssText = inactive;
                } else {
                    btnR.style.cssText = active + 'background:#3b82f6;color:white;';
                    btnL.style.cssText = inactive;
                }
            }
            if (infoEl && info) {
                infoEl.textContent = `${info.model} â†’ ${info.base_url || '?'}`;
            }
        }
    }

    function _populateAllSelects(rawModels, currentModel) {
        const saved = localStorage.getItem('editor_model');
        const models = (rawModels || []).filter(m => !EMBED_MODELS.some(e => m.name.startsWith(e)));
        const modelNames = models.map(m => m.name);
        let target = null;
        if (saved && modelNames.includes(saved)) target = saved;
        else if (currentModel && modelNames.includes(currentModel)) target = currentModel;
        else if (models.length) target = models[0].name;

        for (const selId of MODEL_SELECT_IDS) {
            const sel = document.getElementById(selId);
            if (!sel) continue;
            sel.innerHTML = '';
            if (!models.length) { sel.innerHTML = '<option value="">ëª¨ë¸ ì—†ìŒ</option>'; continue; }
            for (const m of models) {
                const opt = document.createElement('option');
                opt.value = m.name;
                opt.textContent = m.name + (m.size_gb ? ` (${m.size_gb}GB)` : '');
                if (m.name === target) opt.selected = true;
                sel.appendChild(opt);
            }
        }
        if (target) localStorage.setItem('editor_model', target);
        return target;
    }

    function _setAllSelectsLoading() {
        for (const selId of MODEL_SELECT_IDS) {
            const sel = document.getElementById(selId);
            if (sel) sel.innerHTML = '<option value="">ëª¨ë¸ ë¡œë”©...</option>';
        }
    }

    async function _setServerModel(model) {
        try {
            const res = await fetch('/api/llm/model', {
                method: 'POST',
                headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
                body: `model=${encodeURIComponent(model)}`
            });
            const data = await res.json();
            if (data.success) updateModeUI(data.info?.mode, data.info);
        } catch(e) { console.warn('Model switch failed:', e); }
    }

    async function switchLlmMode(mode) {
        // Disable all mode buttons
        for (const ids of MODE_BTN_IDS) {
            const bL = document.getElementById(ids.local); if (bL) bL.disabled = true;
            const bR = document.getElementById(ids.remote); if (bR) bR.disabled = true;
        }
        _setAllSelectsLoading();
        try {
            const res = await fetch('/api/llm/mode', {
                method: 'POST',
                headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
                body: `mode=${mode}`
            });
            const data = await res.json();
            if (data.success) {
                updateModeUI(data.mode, data.info);
                if (data.models) {
                    const selected = _populateAllSelects(data.models, data.info?.model);
                    if (selected) await _setServerModel(selected);
                }
            } else {
                alert(data.detail || 'Mode ì „í™˜ ì‹¤íŒ¨');
            }
        } catch(e) { alert('Mode ì „í™˜ ì˜¤ë¥˜: ' + e.message); }
        finally {
            for (const ids of MODE_BTN_IDS) {
                const bL = document.getElementById(ids.local); if (bL) bL.disabled = false;
                const bR = document.getElementById(ids.remote); if (bR) bR.disabled = false;
            }
        }
    }

    async function loadModelList() {
        _setAllSelectsLoading();
        try {
            const res = await fetch('/api/llm/models');
            const data = await res.json();
            const selected = _populateAllSelects(data.models, data.current);
            if (selected) await _setServerModel(selected);
        } catch(e) {
            console.warn('Model list load failed:', e);
            for (const selId of MODEL_SELECT_IDS) {
                const sel = document.getElementById(selId);
                if (sel) sel.innerHTML = '<option value="">ë¡œë“œ ì‹¤íŒ¨</option>';
            }
        }
    }

    // Model select change handler (shared for both selects)
    function _onModelSelectChange(e) {
        if (!e.target.value) return;
        const model = e.target.value;
        localStorage.setItem('editor_model', model);
        // Sync the other select
        for (const selId of MODEL_SELECT_IDS) {
            const sel = document.getElementById(selId);
            if (sel && sel !== e.target) sel.value = model;
        }
        _setServerModel(model);
    }
    for (const selId of MODEL_SELECT_IDS) {
        const sel = document.getElementById(selId);
        if (sel) sel.addEventListener('change', _onModelSelectChange);
    }

    // On page load
    document.addEventListener('DOMContentLoaded', async () => {
        try {
            const res = await fetch('/api/llm/mode');
            const data = await res.json();
            updateModeUI(data.mode, data.info);
        } catch(e) {}
        await loadModelList();
    });

    async function manualize(docId, force = false) {
        currentDocId = docId;

        // Step 1: Check for existing sections (non-force only)
        if (!force) {
            showModal('í™•ì¸ ì¤‘...', 'ê¸°ì¡´ ë§¤ë‰´ì–¼ ë°ì´í„° í™•ì¸ ì¤‘...');
            const secRes = await fetch(`/api/doc/${docId}/sections`);
            const secData = await secRes.json();
            const existingSections = secData.sections || secData;
            const completedPhases = secData.completed_phases || '';
            if (existingSections && existingSections.length > 0) {
                const details = {};
                existingSections.forEach(s => details[s.section_name] = s.section_text);
                closeModal();
                showConfirmModalForCache(
                    'ì´ë¯¸ ë§¤ë‰´ì–¼í™”ê°€ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤',
                    `ì´ë¯¸ ìƒì„±ëœ ì„¹ì…˜(${existingSections.length}ê°œ)ì´ ìˆìŠµë‹ˆë‹¤. ì–´ë–»ê²Œ í•˜ì‹œê² ìŠµë‹ˆê¹Œ?`,
                    () => { openEditorWithData(docId, { section_details: details, todo_questions: [], sections_gate: existingSections }); _restorePhases(completedPhases, existingSections.length); },
                    () => manualize(docId, true)
                );
                return;
            }
            closeModal();
        }

        // Step 2: Pre-fetch char count, show Manualizing lamp + timer
        const lamp = document.getElementById('manualize-status');
        const timerEl = document.getElementById('manualize-timer');

        let totalChars = 0;
        let windowCount = 1;
        try {
            const ccRes = await fetch(`/api/doc/${docId}/char-count`);
            const ccData = await ccRes.json();
            totalChars = ccData.chars || 0;
            windowCount = ccData.window_count || 1;
        } catch(e) {}

        const charsLabel = totalChars > 0 ? ` Â· ${totalChars.toLocaleString()}ì` : '';
        const unitLabel = 'ì„¹ì…˜';
        const splitLabel = windowCount > 1 ? ` (${windowCount}${unitLabel})` : '';
        if (lamp) { lamp.style.display = 'inline'; lamp.textContent = `Manualizing...${charsLabel}${splitLabel}`; }
        let timerInterval = null;
        const timerStart = Date.now();
        if (timerEl) {
            timerEl.style.display = 'inline';
            timerInterval = setInterval(() => {
                const _sec = (Date.now() - timerStart) / 1000;
                const _m = Math.floor(_sec / 60);
                const _s = (_sec % 60).toFixed(1);
                timerEl.textContent = _m > 0 ? `${_m}:${_s.padStart(4,'0')}` : `${_s}s`;
            }, 100);
        }

        // Cancel button
        const cancelBtn = document.createElement('button');
        cancelBtn.textContent = 'âœ• ì·¨ì†Œ';
        cancelBtn.style.cssText = 'margin-left:6px;padding:2px 8px;border-radius:8px;font-size:11px;border:1px solid #fca5a5;background:#fff;color:#dc2626;cursor:pointer;';
        const abortCtrl = new AbortController();
        cancelBtn.onclick = async () => {
            try { await fetch(`/api/doc/${docId}/manualize-cancel`, { method: 'POST' }); } catch(e) {}
            abortCtrl.abort();
        };
        if (timerEl) timerEl.after(cancelBtn);

        // Step 3: Open editor immediately for streaming
        _openEditorStreaming(docId);
        const addedSections = new Set();
        let sectionIdx = 0;

        // ì§„í–‰ë¥  í´ë§ (2ì´ˆ ê°„ê²©) + ì„¹ì…˜ ìŠ¤íŠ¸ë¦¬ë°
        let progressIv = setInterval(async () => {
            try {
                const pRes = await fetch(`/api/doc/${docId}/manualize-progress`);
                const p = await pRes.json();
                if (p.total > 0 && lamp) {
                    lamp.textContent = `Manualizing...${charsLabel} Â· ${p.done}/${p.total}${unitLabel}`;
                }
                // Stream completed sections into editor
                if (p.sections) {
                    for (const [name, text] of Object.entries(p.sections)) {
                        if (!addedSections.has(name)) {
                            addedSections.add(name);
                            _appendSectionCard(name, text, sectionIdx++);
                        }
                    }
                }
            } catch(e) {}
        }, 2000);

        // Cleanup helper
        function _cleanup() {
            if (timerInterval) clearInterval(timerInterval);
            if (progressIv) clearInterval(progressIv);
            if (cancelBtn.parentNode) cancelBtn.remove();
            if (timerEl) timerEl.style.display = 'none';
        }
        function _elapsed() {
            const _elapsedRaw = (Date.now() - timerStart) / 1000;
            const _em = Math.floor(_elapsedRaw / 60);
            const _es = (_elapsedRaw % 60).toFixed(1);
            return _em > 0 ? `${_em}ë¶„ ${_es}ì´ˆ` : `${_es}ì´ˆ`;
        }

        try {
            const url = force ? `/api/doc/${docId}/manualize?force=true` : `/api/doc/${docId}/manualize`;
            const res = await fetch(url, { method: 'POST', signal: abortCtrl.signal });
            const data = await res.json();

            _cleanup();
            const elapsed = _elapsed();

            if (!res.ok || !data.success) {
                if (lamp) {
                    lamp.textContent = `Manualize ì‹¤íŒ¨`;
                    lamp.style.cssText = 'display:inline;background:#fecaca;color:#991b1b;animation:none;padding:2px 10px;border-radius:8px;font-size:12px;font-weight:700;';
                }
                showModal('Manualize ì‹¤íŒ¨', `ì›ì¸: ${data.detail || 'ì•Œ ìˆ˜ ì—†ëŠ” ì˜¤ë¥˜'}\nì†Œìš”ì‹œê°„: ${elapsed}`);
                return;
            }

            // â”€â”€ ì„±ê³µ: í´ë§ì—ì„œ ë†“ì¹œ ì„¹ì…˜ ì¶”ê°€ â”€â”€
            if (data.section_details) {
                for (const [name, text] of Object.entries(data.section_details)) {
                    if (!addedSections.has(name)) {
                        addedSections.add(name);
                        _appendSectionCard(name, text, sectionIdx++);
                    }
                }
            }

            const sectionCount = Object.keys(data.section_details || {}).length;
            const charInfo = data.raw_text_chars ? `${data.raw_text_chars.toLocaleString()}ì` : '';
            if (lamp) {
                lamp.textContent = `Manualize ì™„ë£Œ Â· ${sectionCount}ê°œ ì„¹ì…˜ Â· ${elapsed}${charInfo ? ' Â· ' + charInfo : ''}`;
                lamp.style.cssText = 'display:inline;background:#dcfce7;color:#166534;animation:none;padding:2px 10px;border-radius:8px;font-size:12px;font-weight:700;';
                setTimeout(() => { lamp.style.display = 'none'; lamp.style.cssText = ''; }, 8000);
            }
        } catch(e) {
            _cleanup();
            const elapsed = _elapsed();
            const isCancelled = e.name === 'AbortError';
            if (lamp) {
                lamp.textContent = isCancelled ? 'Manualize ì·¨ì†Œë¨' : 'Manualize ì‹¤íŒ¨';
                lamp.style.cssText = 'display:inline;background:#fecaca;color:#991b1b;animation:none;padding:2px 10px;border-radius:8px;font-size:12px;font-weight:700;';
                setTimeout(() => { lamp.style.display = 'none'; lamp.style.cssText = ''; lamp.className = 'manualize-lamp'; }, 5000);
            }
            if (!isCancelled) {
                showModal('Manualize ì‹¤íŒ¨', `ë„¤íŠ¸ì›Œí¬ ì˜¤ë¥˜: ${e.message}\nì†Œìš”ì‹œê°„: ${elapsed}`);
            }
        }
    }

    function showConfirmModalForCache(title, content, onOpenEditor, onManualizeAgain) {
        document.getElementById('modal-title').textContent = title;
        document.getElementById('modal-body').textContent = content;
        const btnArea = document.getElementById('modal-buttons');
        btnArea.innerHTML = `
            <button class="btn-small" style="background:#9ca3af;color:white;padding:8px 16px;border:none;border-radius:4px;cursor:pointer;" onclick="closeModal()">ë‹«ê¸°</button>
            <button class="btn-small" style="background:#3b82f6;color:white;padding:8px 16px;border:none;border-radius:4px;cursor:pointer;" id="modal-edit-btn">âœï¸ ì—ë””í„° ì—´ê¸°</button>
            <button class="btn-small" style="background:#8b5cf6;color:white;padding:8px 16px;border:none;border-radius:4px;cursor:pointer;" id="modal-again-btn">âœ¨ AI ë‹¤ì‹œ ë¶„ì„</button>
        `;
        btnArea.style.display = 'flex';
        document.getElementById('modal-edit-btn').onclick = () => { closeModal(); onOpenEditor(); };
        document.getElementById('modal-again-btn').onclick = () => { closeModal(); onManualizeAgain(); };
        document.getElementById('result-modal').style.display = 'flex';
    }

    function _gateBadgeHTML(status) {
        if (!status) return '';
        const badges = {
            'PASS': '<span style="background:#dcfce7;color:#166534;padding:2px 8px;border-radius:4px;font-size:11px;font-weight:700;margin-left:6px;">âœ… PASS</span>',
            'NEED_FIX': '<span style="background:#fef3c7;color:#92400e;padding:2px 8px;border-radius:4px;font-size:11px;font-weight:700;margin-left:6px;">ğŸ”§ NEED_FIX</span>',
            'BLOCK': '<span style="background:#fef2f2;color:#991b1b;padding:2px 8px;border-radius:4px;font-size:11px;font-weight:700;margin-left:6px;">â›” BLOCK</span>'
        };
        return badges[status] || '';
    }

    function _gateHintHTML(status) {
        if (!status) return '';
        const hints = {
            'PASS': '<div style="font-size:12px;color:#166534;margin-bottom:6px;">âœ… RAG ë°˜ì˜ ê°€ëŠ¥ (PASS)</div>',
            'NEED_FIX': '<div style="font-size:12px;color:#92400e;margin-bottom:6px;">ğŸ”§ ìˆ˜ì • í›„ Gate ì¬ê²€ì¦ í•„ìš”</div>',
            'BLOCK': '<div style="font-size:12px;color:#991b1b;margin-bottom:6px;">â›” ìˆ˜ë™ ìˆ˜ì • í•„ìš” (BLOCK)</div>'
        };
        return hints[status] || '';
    }

    function renderGateReasonsHTML(gateStatus, gateReasonsJson, sectionIdx, timeS) {
        let reasons = [];
        try { reasons = JSON.parse(gateReasonsJson || '[]'); } catch(e) {}
        if (!reasons.length && !timeS) return '';
        const active = reasons.filter(r => !r.dismissed);
        const effectiveStatus = active.length === 0 ? 'PASS' : gateStatus;
        if (effectiveStatus === 'PASS' && !reasons.some(r => r.dismissed) && !timeS) return '';
        const color = effectiveStatus === 'BLOCK' ? '#991b1b' : effectiveStatus === 'PASS' ? '#166534' : '#92400e';
        const bg = effectiveStatus === 'BLOCK' ? '#fef2f2' : effectiveStatus === 'PASS' ? '#f0fdf4' : '#fffbeb';
        const border = effectiveStatus === 'BLOCK' ? '#fecaca' : effectiveStatus === 'PASS' ? '#bbf7d0' : '#fde68a';
        const label = effectiveStatus === 'BLOCK' ? 'BLOCK' : effectiveStatus === 'PASS' ? 'PASS' + (reasons.some(r => r.dismissed) ? ' (ë¬´ì‹œë¨ í¬í•¨)' : '') : 'NEED_FIX';
        const timeLabel = timeS ? `<span style="font-size:11px;color:#6b7280;font-family:monospace;">${timeS}s</span>` : '';
        return `<div class="gate-reasons-box" id="gate-reasons-${sectionIdx}" style="background:${bg};color:${color};border:1px solid ${border};border-radius:6px;padding:8px 12px;margin-bottom:8px;font-size:13px;">
            <div style="display:flex;justify-content:space-between;align-items:center;">
                <strong>${label}${active.length ? ' â€” ' + active.length + 'ê±´' : ''}</strong>
                ${timeLabel}
            </div>
            <div id="gate-unmatched-${sectionIdx}"></div>
        </div>`;
    }

    function applyGateSuggestion(sectionIdx, reasonIndex) {
        const textarea = document.getElementById(`editor-${sectionIdx}`);
        if (!textarea) return;
        let reasons = [];
        try {
            let raw = textarea.dataset.gateReasons || '[]';
            reasons = JSON.parse(raw);
            if (typeof reasons === 'string') reasons = JSON.parse(reasons);
        } catch(e) { return; }
        const r = reasons[reasonIndex];
        if (!r || !r.fix_suggestion) return;

        const text = textarea.value;
        const hint = (r.location_hint || '').trim();
        let insertPos = -1;

        // Find the hint location in text, insert suggestion after that line
        if (hint) {
            const hintIdx = text.indexOf(hint);
            if (hintIdx >= 0) {
                const lineEnd = text.indexOf('\n', hintIdx);
                insertPos = lineEnd >= 0 ? lineEnd + 1 : text.length;
            }
        }

        const suggestionLine = `[TODO: ${r.fix_suggestion}]\n`;
        if (insertPos >= 0) {
            textarea.value = text.substring(0, insertPos) + suggestionLine + text.substring(insertPos);
        } else {
            // Fallback: append at end
            textarea.value = text + '\n' + suggestionLine;
        }

        // Trigger input event for auto-resize
        textarea.dispatchEvent(new Event('input'));
        // Scroll to inserted position
        if (insertPos >= 0) {
            textarea.setSelectionRange(insertPos, insertPos + suggestionLine.length);
            textarea.focus();
        }
    }

    function openEditorWithData(docId, data) {
        currentDocId = docId;
        sourceMapCache = null;
        // RAG ë°˜ì˜ ë²„íŠ¼ ì´ˆê¸°í™”: í•­ìƒ disabledë¡œ ì‹œì‘
        _disableBtn('btn-publish-all', 'ğŸ“¦ RAG ë°˜ì˜');
        // Load model list and restore saved selection
        loadModelList();
        const container = document.getElementById('editor-container');
        container.innerHTML = '';

        // Add Change Summary if any
        if (data.change_summary) {
            const sumDiv = document.createElement('div');
            sumDiv.className = 'info';
            sumDiv.style.background = '#f0fdf4';
            sumDiv.style.color = '#166534';
            sumDiv.style.border = '1px solid #bbf7d0';
            sumDiv.style.marginBottom = '1rem';
            sumDiv.innerHTML = `<strong>âœ¨ AI ë¶„ì„ ìš”ì•½</strong><br>${data.change_summary}`;
            container.appendChild(sumDiv);
        }

        if (data.todo_questions && data.todo_questions.length > 0) {
            const todoDiv = document.createElement('div');
            todoDiv.className = 'info';
            todoDiv.style.marginBottom = '1rem';
            todoDiv.innerHTML = `<strong>ğŸ“Œ AI ë³´ê°• ìš”ì²­ì‚¬í•­</strong><ul style="margin-left:1.5rem;margin-top:0.5rem;">${data.todo_questions.map(q => `<li>${q}</li>`).join('')}</ul>`;
            container.appendChild(todoDiv);
        }

        // Build gate info map from sections data OR gate_results (from manualize)
        const gateInfo = {};
        const evidenceInfo = {};
        const mergeStatusInfo = {};
        if (data.sections_gate) {
            data.sections_gate.forEach(s => {
                gateInfo[s.section_name] = { status: s.gate_status, reasons: s.gate_reasons_json, stale: s.gate_stale };
                if (s.evidence_json) evidenceInfo[s.section_name] = s.evidence_json;
                if (s.merge_status) mergeStatusInfo[s.section_name] = s.merge_status;
            });
        }
        if (data.gate_results) {
            Object.entries(data.gate_results).forEach(([name, g]) => {
                gateInfo[name] = { status: g.status, reasons: JSON.stringify(g.reasons || []), stale: 0 };
            });
        }
        // evidence_summary from manualize response
        if (data.evidence_summary) {
            Object.entries(data.evidence_summary).forEach(([name, info]) => {
                if (!evidenceInfo[name]) evidenceInfo[name] = null;
                evidenceInfo[name + '__summary'] = info;
            });
        }

        let sectionIndex = 0;
        Object.entries(data.section_details).forEach(([name, text]) => {
            const idx = sectionIndex++;
            const gate = gateInfo[name] || {};
            const isStale = gate.stale === 1 || gate.stale === true;
            const gateHTML = renderGateReasonsHTML(gate.status, gate.reasons, idx);
            const gateBadge = isStale
                ? '<span style="background:#fef3c7;color:#d97706;padding:2px 8px;border-radius:4px;font-size:11px;font-weight:700;margin-left:6px;">âš ï¸ ë¯¸ê²€ì¦</span>'
                : _gateBadgeHTML(gate.status);
            const gateHint = isStale
                ? '<div style="font-size:12px;color:#d97706;margin-bottom:6px;">âš ï¸ ë³€ê²½ë¨: Gate ì¬ê²€ì¦ í•„ìš”</div>'
                : _gateHintHTML(gate.status);
            const fillDisabled = (!isStale && (gate.status === 'PASS' || gate.status === 'BLOCK')) ? 'disabled style="background:#10b981;color:white;opacity:0.4;cursor:not-allowed;"' : 'style="background:#10b981;color:white;"';

            // Evidence button
            let evidenceCount = 0;
            let evidenceRaw = evidenceInfo[name] || null;
            if (evidenceRaw) {
                try {
                    const spans = typeof evidenceRaw === 'string' ? JSON.parse(evidenceRaw) : evidenceRaw;
                    if (Array.isArray(spans)) evidenceCount = spans.length;
                } catch(e) {}
            }
            const evidenceBtnHTML = evidenceCount > 0
                ? `<button class="btn-small" style="background:#8b5cf6;color:white;font-size:11px;padding:2px 6px;" onclick="toggleEvidence(${idx})">ğŸ“ Evidence (${evidenceCount})</button>`
                : '';

            // Appendix styling
            const isAppendix = name.startsWith('[ë¶€ë¡]') || mergeStatusInfo[name] === 'APPENDIX';
            const cardBg = isAppendix ? 'background:#fff7ed;border-left:4px solid #fb923c;' : '';

            const secDiv = document.createElement('div');
            secDiv.id = `section-card-${idx}`;
            secDiv.className = 'card';
            secDiv.style.cssText = 'margin:0;transition:opacity 0.3s,box-shadow 0.3s;' + cardBg;
            secDiv.innerHTML = `
                ${gateHTML}
                <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:0.5rem;">
                    <div style="display:flex; align-items:center; gap:0.4rem;">
                        <strong>${name} ${gateBadge}</strong>
                        <span id="phase-done-${idx}" style="display:none;font-size:12px;font-weight:700;padding:1px 6px;border-radius:4px;"></span>
                        ${evidenceBtnHTML}
                        <button id="btn-highlight-${idx}" class="btn-small" style="background:#f59e0b;color:white;font-size:11px;padding:2px 6px;${(gate.status === 'NEED_FIX' || gate.status === 'BLOCK') ? '' : 'display:none;'}" onclick="toggleHighlight(${idx})">ğŸ” ë¬¸ì œ í‘œì‹œ</button>
                    </div>
                    <div style="display:flex; gap:0.25rem; align-items:center;">
                        <button class="btn-small" style="background:#64748b;color:white;" onclick="toggleSectionSource(${idx})">ğŸ“„ ì›ë³¸ ë¹„êµ</button>
                        <button class="btn-small" style="background:#94a3b8;color:white;font-size:11px;" onclick="toggleMoreBtns(${idx})">â‹¯ ë”ë³´ê¸°</button>
                        <span id="more-btns-${idx}" style="display:none; gap:0.25rem; align-items:center;">
                            <button id="btn-fill-${idx}" class="btn-small" ${fillDisabled} onclick="aiRefine(${idx}, 'fill')">â‘  ë§¥ë½ ë³´ê°•</button>
                            <button id="btn-refine-${idx}" class="btn-small" style="background:#6366f1;color:white;" onclick="aiRefine(${idx}, 'refine')">â‘¡ RAG ìµœì í™”</button>
                            <button id="btn-gate-${idx}" class="btn-small" style="background:#f59e0b;color:white;" onclick="gateSectionUI(${idx})">â‘¢ Gate ê²€ì¦</button>
                        </span>
                    </div>
                </div>
                ${gateHint}
                <div id="evidence-panel-${idx}" class="evidence-panel" style="display:none;" data-evidence='${(evidenceRaw || "[]").replace(/'/g, "&#39;")}'></div>
                <div id="section-row-${idx}" class="section-row">
                    <div id="source-panel-${idx}" class="source-panel" style="display:none;"></div>
                    <div class="editor-panel">
                        <div id="editor-label-${idx}" class="column-label" style="display:none;">ë§¤ë‰´ì–¼ í…ìŠ¤íŠ¸</div>
                        <textarea id="editor-${idx}" class="editor-textarea" data-section-name="${name.replace(/"/g, '&quot;')}" data-gate-status="${gate.status || ''}" data-gate-reasons='${(gate.reasons || "[]").replace(/'/g, "&#39;")}' oninput="autoResize(this)">${text}</textarea>
                        <div id="highlight-${idx}" class="highlight-preview" style="display:none;"></div>
                    </div>
                </div>
            `;
            container.appendChild(secDiv);
        });

        document.getElementById('editor-modal').style.display = 'flex';

        // Auto-resize all textareas after rendering
        requestAnimationFrame(() => {
            container.querySelectorAll('.editor-textarea').forEach(ta => autoResize(ta));
        });

        // RAG ë°˜ì˜ ë²„íŠ¼: ëª¨ë“  ì„¹ì…˜ì´ PASSì¼ ë•Œë§Œ í™œì„±í™”
        const gateValues = Object.values(gateInfo);
        const allPass = gateValues.length > 0 && gateValues.every(g => g.status === 'PASS');
        if (allPass) _enableBtn('btn-publish-all', 'ğŸ“¦ RAG ë°˜ì˜');
        else _disableBtn('btn-publish-all', 'ğŸ“¦ RAG ë°˜ì˜');
    }

    async function openEditor(docId) {
        const res = await fetch(`/api/doc/${docId}/sections`);
        const secData = await res.json();
        const sections = secData.sections || secData;
        const completedPhases = secData.completed_phases || '';
        const details = {};
        sections.forEach(s => details[s.section_name] = s.section_text);
        openEditorWithData(docId, { section_details: details, todo_questions: [], sections_gate: sections });
        _restorePhases(completedPhases, sections.length);
    }

    function _openEditorStreaming(docId) {
        currentDocId = docId;
        sourceMapCache = null;
        _disableBtn('btn-publish-all', 'ğŸ“¦ RAG ë°˜ì˜');
        loadModelList();
        const container = document.getElementById('editor-container');
        container.innerHTML = '';
        document.getElementById('editor-modal').style.display = 'flex';
    }

    function _appendSectionCard(name, text, idx) {
        const container = document.getElementById('editor-container');
        const secDiv = document.createElement('div');
        secDiv.id = `section-card-${idx}`;
        secDiv.className = 'card';
        secDiv.style.cssText = 'margin:0;transition:opacity 0.3s;';
        const escapedName = name.replace(/"/g, '&quot;').replace(/</g, '&lt;');
        secDiv.innerHTML = `
            <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:0.5rem;">
                <div style="display:flex; align-items:center; gap:0.4rem;">
                    <strong>${name}</strong>
                    <span id="phase-done-${idx}" style="display:none;font-size:12px;font-weight:700;padding:1px 6px;border-radius:4px;"></span>
                </div>
                <div style="display:flex; gap:0.25rem; align-items:center;">
                    <button class="btn-small" style="background:#64748b;color:white;" onclick="toggleSectionSource(${idx})">ğŸ“„ ì›ë³¸ ë¹„êµ</button>
                    <button class="btn-small" style="background:#94a3b8;color:white;font-size:11px;" onclick="toggleMoreBtns(${idx})">â‹¯ ë”ë³´ê¸°</button>
                    <span id="more-btns-${idx}" style="display:none; gap:0.25rem; align-items:center;">
                        <button id="btn-fill-${idx}" class="btn-small" style="background:#10b981;color:white;" onclick="aiRefine(${idx}, 'fill')">â‘  ë§¥ë½ ë³´ê°•</button>
                        <button id="btn-refine-${idx}" class="btn-small" style="background:#6366f1;color:white;" onclick="aiRefine(${idx}, 'refine')">â‘¡ RAG ìµœì í™”</button>
                        <button id="btn-gate-${idx}" class="btn-small" style="background:#f59e0b;color:white;" onclick="gateSectionUI(${idx})">â‘¢ Gate ê²€ì¦</button>
                    </span>
                </div>
            </div>
            <div id="section-row-${idx}" class="section-row">
                <div id="source-panel-${idx}" class="source-panel" style="display:none;"></div>
                <div class="editor-panel">
                    <div id="editor-label-${idx}" class="column-label" style="display:none;">ë§¤ë‰´ì–¼ í…ìŠ¤íŠ¸</div>
                    <textarea id="editor-${idx}" class="editor-textarea" data-section-name="${escapedName}" data-gate-status="" data-gate-reasons="[]" oninput="autoResize(this)">${text}</textarea>
                    <div id="highlight-${idx}" class="highlight-preview" style="display:none;"></div>
                </div>
            </div>
        `;
        container.appendChild(secDiv);
        requestAnimationFrame(() => {
            const ta = document.getElementById(`editor-${idx}`);
            if (ta) autoResize(ta);
        });
    }

    async function qualityGate(docId) {
        showModal('í’ˆì§ˆ ê²€ì‚¬ ë° API ì¶”ì¶œ ì¤‘...', 'ë§¤ë‰´ì–¼ í’ˆì§ˆì„ ê²€ì¦í•˜ê³  ì‹œìŠ¤í…œ ì—°ë™ì„ ìœ„í•œ API ìŠ¤í™ì„ ì¶”ì¶œí•˜ê³  ìˆìŠµë‹ˆë‹¤...');
        const { ok, data } = await apiCall(`/api/doc/${docId}/quality-gate`);
        if (ok) {
            let apiHtml = '';
            if (data.api_specs && data.api_specs.length > 0) {
                apiHtml = `\n\n[ì¶”ì¶œëœ API ëª©ë¡]\n` + data.api_specs.map(s => `- ${s.intent}: ${s.method} ${s.endpoint}`).join('\n');
            }
            showModal('ê²€ì¦ ë° ì¶”ì¶œ ì™„ë£Œ', `RED: ${data.red_count}, YELLOW: ${data.yellow_count}\n\nì´ìŠˆ:\n${JSON.stringify(data.issues, null, 2)}${apiHtml}`);

            const approveBtn = document.getElementById(`approve-btn-${docId}`);
            if (approveBtn) {
                approveBtn.disabled = data.red_count > 0;
                if (data.red_count > 0) {
                    approveBtn.style.opacity = '0.5';
                    approveBtn.title = "RED ì´ìŠˆë¥¼ í•´ê²°í•´ì•¼ RAG ë°ì´í„°í™”ê°€ ê°€ëŠ¥í•©ë‹ˆë‹¤.";
                } else {
                    approveBtn.style.opacity = '1';
                    approveBtn.title = "";
                }
            }
        } else {
            showModal('ì˜¤ë¥˜', data.detail || data.error);
        }
    }

    function closeEditor() {
        document.getElementById('editor-modal').style.display = 'none';
    }

    let compareTargetIdx = null;
    let compareTargetTask = null;

    function autoResize(el) {
        el.style.height = 'auto';
        el.style.height = el.scrollHeight + 'px';
    }

    async function aiRefine(idx, task) {
        const textarea = document.getElementById(`editor-${idx}`);
        const sectionName = textarea.dataset.sectionName;
        const originalText = textarea.value;
        const taskLabel = task === 'fill' ? 'â‘  ë§¥ë½ ë³´ê°•' : 'â‘¡ RAG ìµœì í™”';
        const taskBtn = document.getElementById(task === 'fill' ? `btn-fill-${idx}` : `btn-refine-${idx}`);

        // ì§„í–‰ ì¤‘ ì‹œê° íš¨ê³¼
        if (taskBtn) { taskBtn.disabled = true; taskBtn.textContent = taskLabel + ' ì¤‘...'; }
        _markSectionWorking(idx, taskLabel + ' ì¤‘â€¦');
        textarea.value = "AIê°€ ì‘ì„± ì¤‘ì…ë‹ˆë‹¤...";
        textarea.disabled = true;
        autoResize(textarea);

        const body = { text: originalText, task: task, context: sectionName };
        if (task === 'fill') {
            body.allow_qa = 'false';
        }

        try {
            const res = await fetch(`/api/doc/${currentDocId}/refine-text`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(body)
            });
            const result = await res.json();

            textarea.disabled = false;
            textarea.value = originalText;
            autoResize(textarea);

            if (res.ok) {
                openCompare(idx, sectionName, originalText, result.suggestion, task);
            } else {
                alert(result.detail || "AI ìš”ì²­ ì‹¤íŒ¨");
            }
        } catch(e) {
            textarea.disabled = false;
            textarea.value = originalText;
            autoResize(textarea);
            alert('AI ìš”ì²­ ì‹¤íŒ¨: ' + e.message);
        } finally {
            // íš¨ê³¼ í•´ì œ (ì ìš©ì€ applyCompareì—ì„œ âœ“ ì²˜ë¦¬)
            if (taskBtn) { taskBtn.disabled = false; taskBtn.textContent = taskLabel; }
            const badge = document.getElementById(`phase-done-${idx}`);
            if (badge) { badge.classList.remove('badge-working'); if (badge.textContent.includes('ì¤‘â€¦')) badge.style.display = 'none'; }
        }
    }

    function openCompare(idx, sectionName, before, after, task) {
        compareTargetIdx = idx;
        compareTargetTask = task;
        const taskLabel = task === 'refine' ? 'â‘¡ RAG ìµœì í™”' : 'â‘  ë§¥ë½ ë³´ê°•';
        const titleEl = document.getElementById('compare-title');
        // ë³€ê²½ ì—†ìœ¼ë©´ ì•ˆë‚´
        const trimBefore = before.trim();
        const trimAfter = (after || '').trim();
        const isSame = trimBefore === trimAfter || !trimAfter;
        if (isSame) {
            titleEl.textContent = `ğŸ”„ ${taskLabel} ë¹„êµ â€” ${sectionName} (âš ï¸ ë³€ê²½ ì—†ìŒ â€” ì˜¤ë¥¸ìª½ì„ ì§ì ‘ ìˆ˜ì •í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤)`;
        } else {
            titleEl.textContent = `ğŸ”„ ${taskLabel} ë¹„êµ â€” ${sectionName}`;
        }
        document.getElementById('compare-before').textContent = before;
        const afterTA = document.getElementById('compare-after');
        afterTA.value = after || before;
        document.getElementById('compare-modal').style.display = 'flex';
        requestAnimationFrame(() => {
            afterTA.style.height = 'auto';
            afterTA.style.height = afterTA.scrollHeight + 'px';
        });
    }

    function closeCompare() {
        document.getElementById('compare-modal').style.display = 'none';
        compareTargetIdx = null;
        compareTargetTask = null;
        // Restore default buttons (in case bulk mode changed them)
        const modal = document.getElementById('compare-modal');
        const footer = modal.querySelector('div[style*="justify-content: flex-end"]');
        if (footer) {
            footer.innerHTML = `
                <button class="btn" style="background:#9ca3af;" onclick="closeCompare()">âŒ ì·¨ì†Œ (ì›ë˜ ìœ ì§€)</button>
                <button class="btn" style="background:#6b7280;" onclick="applyCompareSaveOnly()">âœ… ì ìš©(ì €ì¥)</button>
                <button class="btn" style="background:#3b82f6;" onclick="applyCompareSaveAndGate()">âœ… ì ìš© + Gate ì¬ê²€ì¦</button>
            `;
        }
    }

    async function applyCompareSaveOnly() {
        if (compareTargetIdx === null) return;
        const idx = compareTargetIdx;
        const task = compareTargetTask;
        const textarea = document.getElementById(`editor-${idx}`);
        textarea.value = document.getElementById('compare-after').value;
        autoResize(textarea);
        closeCompare();
        await saveEditor(true);
        // Snapshot AI text for this section
        const sectionName = textarea.dataset.sectionName;
        await _snapshotAiTextSection(currentDocId, sectionName);

        // Mark step done
        _markSectionBtnDone(idx, task);

        // Set gate_stale flag (saved without gate re-check)
        await setGateStale(sectionName);
        textarea.dataset.gateStatus = 'STALE';
        // Show stale hint on section
        const card = textarea.closest('.card');
        if (card) {
            let staleHint = card.querySelector('.gate-stale-hint');
            if (!staleHint) {
                staleHint = document.createElement('div');
                staleHint.className = 'gate-stale-hint';
                staleHint.style.cssText = 'font-size:12px;color:#d97706;margin-bottom:6px;';
                staleHint.textContent = 'âš ï¸ ë³€ê²½ë¨: Gate ì¬ê²€ì¦ í•„ìš”';
                card.insertBefore(staleHint, card.querySelector('.section-row'));
            }
        }
    }

    async function applyCompareSaveAndGate() {
        if (compareTargetIdx === null) return;
        const idx = compareTargetIdx;
        const task = compareTargetTask;
        const textarea = document.getElementById(`editor-${idx}`);
        textarea.value = document.getElementById('compare-after').value;
        autoResize(textarea);
        closeCompare();
        await saveEditor(true);
        // Snapshot AI text for this section
        const sectionName = textarea.dataset.sectionName;
        await _snapshotAiTextSection(currentDocId, sectionName);

        // Mark step done
        _markSectionBtnDone(idx, task);

        // Run Gate re-check + update UI
        await runGateAndUpdateUI(idx, sectionName);

        // Remove stale hint if exists
        const card = textarea.closest('.card');
        if (card) {
            const staleHint = card.querySelector('.gate-stale-hint');
            if (staleHint) staleHint.remove();
        }
    }

    // Keep old applyCompare as alias for backward compat
    async function applyCompare() { return applyCompareSaveAndGate(); }

    async function setGateStale(sectionName) {
        try {
            await fetch(`/api/doc/${currentDocId}/section/${encodeURIComponent(sectionName)}/gate-stale`, { method: 'POST' });
        } catch(e) {
            console.error('[GATE_STALE]', e);
        }
    }

    async function gateSectionUI(idx) {
        const textarea = document.getElementById(`editor-${idx}`);
        if (!textarea) return;
        const sectionName = textarea.dataset.sectionName;
        const btn = document.getElementById(`btn-gate-${idx}`);
        const card = document.getElementById(`section-card-${idx}`);
        if (btn) { btn.disabled = true; btn.textContent = 'â‘¢ ê²€ì¦ ì¤‘...'; }
        _markSectionWorking(idx, 'â‘¢ ê²€ì¦ ì¤‘â€¦');
        await saveEditor(true);
        await runGateAndUpdateUI(idx, sectionName);
        if (btn) { btn.disabled = false; btn.textContent = 'â‘¢ Gate ê²€ì¦ âœ“'; btn.style.outline = '2px solid #22c55e'; btn.style.outlineOffset = '-2px'; }
        _markSectionPhase(idx, 3);
        // Remove stale hint if exists
        if (card) {
            const staleHint = card.querySelector('.gate-stale-hint');
            if (staleHint) staleHint.remove();
        }
    }

    async function runGateAndUpdateUI(idx, sectionName) {
        try {
            const res = await fetch(`/api/doc/${currentDocId}/section/${encodeURIComponent(sectionName)}/gate`, { method: 'POST' });
            if (!res.ok) return;
            const gate = await res.json();
            updateSectionGateUI(idx, gate.status);
            // Store reasons for highlight
            const textarea = document.getElementById(`editor-${idx}`);
            if (textarea && gate.reasons) {
                textarea.dataset.gateReasons = JSON.stringify(gate.reasons);
            }
            // Re-render gate reasons box with new results
            const reasonsJson = gate.reasons ? JSON.stringify(gate.reasons) : '[]';
            const box = document.getElementById(`gate-reasons-${idx}`);
            const newHTML = renderGateReasonsHTML(gate.status, reasonsJson, idx, gate.time_s);
            if (box) {
                if (newHTML) { box.outerHTML = newHTML; }
                else { box.remove(); }
            } else if (newHTML) {
                const card = document.getElementById(`section-card-${idx}`);
                if (card) card.insertAdjacentHTML('afterbegin', newHTML);
            }
        } catch(e) {
            console.error('[GATE_RECHECK]', e);
        }
    }

    function updateSectionGateUI(idx, status) {
        // Update badge
        const textarea = document.getElementById(`editor-${idx}`);
        if (textarea) textarea.dataset.gateStatus = status || '';

        // Update fill button state
        const fillBtn = document.getElementById(`btn-fill-${idx}`);
        if (fillBtn) {
            if (status === 'PASS' || status === 'BLOCK') {
                fillBtn.disabled = true;
                fillBtn.style.opacity = '0.4';
                fillBtn.style.cursor = 'not-allowed';
            } else {
                fillBtn.disabled = false;
                fillBtn.style.opacity = '1';
                fillBtn.style.cursor = 'pointer';
            }
        }

        // Show/hide highlight button
        const hlBtn = document.getElementById(`btn-highlight-${idx}`);
        if (hlBtn) {
            hlBtn.style.display = (status === 'NEED_FIX' || status === 'BLOCK') ? '' : 'none';
        }

        // Close highlight preview if status changed to PASS
        if (status === 'PASS') {
            const hlDiv = document.getElementById(`highlight-${idx}`);
            if (hlDiv) hlDiv.style.display = 'none';
            if (textarea) textarea.style.display = '';
        }

        // RAG ë°˜ì˜ ë²„íŠ¼: ëª¨ë“  ì„¹ì…˜ PASSì¼ ë•Œ í™œì„±í™”
        const allTAs = document.getElementById('editor-container').querySelectorAll('textarea.editor-textarea');
        const allPass = Array.from(allTAs).every(ta => ta.dataset.gateStatus === 'PASS');
        if (allPass) _enableBtn('btn-publish-all', 'ğŸ“¦ RAG ë°˜ì˜');
        else _disableBtn('btn-publish-all', 'ğŸ“¦ RAG ë°˜ì˜');
    }

    async function dismissGateReason(idx, reasonIndex) {
        const textarea = document.getElementById(`editor-${idx}`);
        if (!textarea) return;
        const sectionName = textarea.dataset.sectionName;
        try {
            const res = await fetch(`/api/doc/${currentDocId}/section/${encodeURIComponent(sectionName)}/gate-dismiss`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ reason_index: reasonIndex })
            });
            if (!res.ok) { alert('ë¬´ì‹œ ì²˜ë¦¬ ì‹¤íŒ¨'); return; }
            const data = await res.json();
            // Update gate status + reasons in dataset
            textarea.dataset.gateStatus = data.status;
            textarea.dataset.gateReasons = JSON.stringify(data.reasons);
            // Re-render reasons box
            const box = document.getElementById(`gate-reasons-${idx}`);
            const newHTML = renderGateReasonsHTML(data.status, JSON.stringify(data.reasons), idx);
            if (box) {
                if (newHTML) { box.outerHTML = newHTML; }
                else { box.remove(); }
            } else if (newHTML) {
                // boxê°€ ì—†ëŠ” ê²½ìš° (PASSì—ì„œ ë¬´ì‹œ í•´ì œ ì‹œ) ì¹´ë“œ ë§¨ ìœ„ì— ì‚½ì…
                const card = document.getElementById(`section-card-${idx}`);
                if (card) card.insertAdjacentHTML('afterbegin', newHTML);
            }
            // Update badge
            const card = document.getElementById(`section-card-${idx}`);
            if (card) {
                const strong = card.querySelector('div > div > strong');
                if (strong) {
                    const oldBadge = strong.querySelector('span[style*="border-radius"]');
                    if (oldBadge) oldBadge.remove();
                    strong.insertAdjacentHTML('beforeend', _gateBadgeHTML(data.status));
                }
            }
            updateSectionGateUI(idx, data.status);
            refreshHighlightIfActive(idx);
            // RAG ë°˜ì˜ ë²„íŠ¼ ìƒíƒœ ê°±ì‹ 
            const allTAs = document.getElementById('editor-container').querySelectorAll('textarea.editor-textarea');
            const allPass = Array.from(allTAs).every(ta => ta.dataset.gateStatus === 'PASS');
            if (allPass) _enableBtn('btn-publish-all', 'ğŸ“¦ RAG ë°˜ì˜');
            else _disableBtn('btn-publish-all', 'ğŸ“¦ RAG ë°˜ì˜');
        } catch(e) {
            console.error('[DISMISS_GATE]', e);
            alert('ë¬´ì‹œ ì²˜ë¦¬ ì˜¤ë¥˜: ' + e.message);
        }
    }

    function dismissGateReasonFromPopover(idx, ri) {
        hideGatePopover();
        dismissGateReason(idx, ri);
    }

    function applyGateSuggestionFromPopover(idx, ri) {
        hideGatePopover();
        // í•˜ì´ë¼ì´íŠ¸ ëª¨ë“œ í•´ì œ â†’ textarea í‘œì‹œ í›„ TODO ì‚½ì…
        const hlDiv = document.getElementById(`highlight-${idx}`);
        if (hlDiv && hlDiv.style.display !== 'none') {
            toggleHighlight(idx);
        }
        applyGateSuggestion(idx, ri);
    }

    function refreshHighlightIfActive(idx) {
        const hlDiv = document.getElementById(`highlight-${idx}`);
        const textarea = document.getElementById(`editor-${idx}`);
        if (!hlDiv || !textarea) return;
        if (hlDiv.style.display === 'none') return;
        // Re-render highlight
        let reasons = [];
        try {
            let raw = textarea.dataset.gateReasons || '[]';
            reasons = JSON.parse(raw);
            if (typeof reasons === 'string') reasons = JSON.parse(reasons);
        } catch(e) {}
        const result = renderHighlightedText(textarea.value, reasons, textarea.dataset.gateStatus, idx);
        hlDiv.innerHTML = result.html;
        renderUnmatchedIssues(idx, reasons, result.unmatchedReasonIndices);
    }

    function renderUnmatchedIssues(idx, reasons, unmatchedIndices) {
        const container = document.getElementById(`gate-unmatched-${idx}`);
        if (!container) return;
        if (!unmatchedIndices || !unmatchedIndices.length) {
            container.innerHTML = '';
            return;
        }
        let html = '<div style="margin-top:6px;padding-top:6px;border-top:1px solid rgba(0,0,0,0.1);font-size:12px;">';
        html += '<div style="font-weight:600;margin-bottom:4px;">ğŸ“Œ í…ìŠ¤íŠ¸ ë§¤ì¹­ ë¶ˆê°€ ì´ìŠˆ:</div>';
        for (const ri of unmatchedIndices) {
            const r = reasons[ri];
            if (!r || r.dismissed) continue;
            const sevColor = r.severity === 'HIGH' ? '#dc2626' : '#d97706';
            const suggestionHTML = r.fix_suggestion
                ? `<span style="color:#2563eb;margin-left:4px;">ğŸ’¡ ${_escHtml(r.fix_suggestion)}</span>`
                : '';
            html += `<div style="padding:3px 0;display:flex;align-items:flex-start;gap:6px;">
                <span style="flex:1;"><span style="color:${sevColor};font-weight:600;">[${_escHtml(r.type || 'ISSUE')}]</span> ${_escHtml(r.message || '')}${suggestionHTML}</span>
                <button onclick="dismissGateReasonFromPopover(${idx},${ri})" style="flex-shrink:0;padding:2px 8px;border:1px solid #d1d5db;border-radius:4px;background:#fff;color:#374151;cursor:pointer;font-size:11px;">ë¬´ì‹œ</button>
            </div>`;
        }
        html += '</div>';
        container.innerHTML = html;
    }

    function toggleEvidence(idx) {
        const panel = document.getElementById(`evidence-panel-${idx}`);
        if (!panel) return;
        if (panel.style.display !== 'none') {
            panel.style.display = 'none';
            return;
        }
        let spans = [];
        try {
            const raw = panel.dataset.evidence || '[]';
            spans = JSON.parse(raw);
            if (typeof spans === 'string') spans = JSON.parse(spans);
        } catch(e) { console.error('[EVIDENCE] parse error', e); }

        if (!spans.length) {
            panel.innerHTML = '<div style="padding:8px;color:#9ca3af;font-size:13px;">Evidence ì—†ìŒ</div>';
        } else {
            let html = '<div style="font-size:13px;">';
            for (const s of spans) {
                let icon = 'âœ…';
                let color = '#166534';
                if (s.is_pii) { icon = 'ğŸ”’'; color = '#d97706'; }
                else if (s.char_start === -1) { icon = 'âŒ'; color = '#dc2626'; }
                html += `<div style="padding:4px 0;border-bottom:1px solid #f3f4f6;color:${color};">
                    ${icon} <code style="background:#f5f5f5;padding:1px 4px;border-radius:2px;font-size:12px;">${_escHtml(s.span_text || '')}</code>
                    <span style="color:#6b7280;font-size:12px;margin-left:6px;">â†’ ${_escHtml(s.maps_to || '')}</span>
                </div>`;
            }
            html += '</div>';
            panel.innerHTML = html;
        }
        panel.style.display = 'block';
    }

    function toggleHighlight(idx) {
        const textarea = document.getElementById(`editor-${idx}`);
        const hlDiv = document.getElementById(`highlight-${idx}`);
        if (!textarea || !hlDiv) return;

        const legendId = `highlight-legend-${idx}`;
        let legendEl = document.getElementById(legendId);

        if (hlDiv.style.display === 'none') {
            // Show highlighted view
            let reasons = [];
            try {
                let raw = textarea.dataset.gateReasons || '[]';
                reasons = JSON.parse(raw);
                if (typeof reasons === 'string') reasons = JSON.parse(reasons);
            } catch(e) { console.error('[HIGHLIGHT] reasons parse error', e); }
            const result = renderHighlightedText(textarea.value, reasons, textarea.dataset.gateStatus, idx);
            hlDiv.innerHTML = result.html;
            renderUnmatchedIssues(idx, reasons, result.unmatchedReasonIndices);
            hlDiv.style.display = 'block';
            textarea.style.display = 'none';
            // Show legend outside panel
            if (!legendEl) {
                const legendHTML = `<div id="${legendId}" style="font-size:11px;color:#6b7280;margin-bottom:4px;display:flex;gap:12px;">
                    <span><mark style="background:#fef08a;padding:1px 4px;border-radius:2px;">ë…¸ë‘</mark> NEED_FIX</span>
                    <span><mark style="background:#fecaca;padding:1px 4px;border-radius:2px;">ë¹¨ê°•</mark> BLOCK</span>
                    <span style="color:#9ca3af;">í´ë¦­í•˜ë©´ ìƒì„¸ ë‚´ìš©</span>
                </div>`;
                hlDiv.insertAdjacentHTML('beforebegin', legendHTML);
            } else {
                legendEl.style.display = 'flex';
            }
        } else {
            // Back to edit mode
            hlDiv.style.display = 'none';
            textarea.style.display = '';
            if (legendEl) legendEl.style.display = 'none';
            // ë†’ì´ ë³µì›
            textarea.style.height = 'auto';
            textarea.style.height = textarea.scrollHeight + 'px';
        }
    }

    function renderHighlightedText(text, reasons, gateStatus, sectionIdx) {
        if (!reasons || !reasons.length) {
            return { html: `<pre style="white-space:pre-wrap;font-family:inherit;margin:0;">${_escHtml(text)}</pre>`, unmatchedReasonIndices: [] };
        }

        // Collect location_hints with their severity (skip dismissed)
        const hints = [];
        const noHintIndices = []; // reasons without location_hint
        for (let ri = 0; ri < reasons.length; ri++) {
            const r = reasons[ri];
            if (r.dismissed) continue;
            if (r.location_hint && r.location_hint.trim()) {
                hints.push({
                    hint: r.location_hint.trim(),
                    severity: r.severity || 'MEDIUM',
                    type: r.type || '',
                    message: r.message || '',
                    suggestion: r.fix_suggestion || '',
                    reasonIdx: ri
                });
            } else {
                noHintIndices.push(ri);
            }
        }

        // Find matches in RAW text (no escaping), collect [start, end, hintObj]
        const matches = [];
        const textLower = text.toLowerCase();
        const lines = text.split('\n');
        // precompute line offsets
        const lineOffsets = [];
        let off = 0;
        for (const ln of lines) { lineOffsets.push(off); off += ln.length + 1; }

        for (const h of hints) {
            const raw = h.hint;
            let pos = text.indexOf(raw);
            // Fallback 1: strip markdown markers and retry
            if (pos < 0) {
                const stripped = raw.replace(/^[#>*\-\s]+/, '').trim();
                if (stripped.length > 5) pos = text.indexOf(stripped);
            }
            // Fallback 2: case-insensitive
            if (pos < 0) {
                pos = textLower.indexOf(raw.toLowerCase());
            }
            // Fallback 3: first 15 chars partial â†’ extend to end of line
            if (pos < 0 && raw.length > 15) {
                const partial = raw.substring(0, 15).toLowerCase();
                pos = textLower.indexOf(partial);
                if (pos >= 0) {
                    const lineEnd = text.indexOf('\n', pos);
                    matches.push({ start: pos, end: lineEnd > pos ? lineEnd : pos + raw.length, h });
                    continue;
                }
            }
            // Fallback 4: keyword-based line match â€” extract 2+ char words, find line with most matches
            if (pos < 0) {
                const keywords = raw.replace(/[^\wê°€-í£]/g, ' ').split(/\s+/).filter(w => w.length >= 2);
                if (keywords.length >= 2) {
                    let bestLine = -1, bestScore = 0;
                    for (let li = 0; li < lines.length; li++) {
                        const lineLower = lines[li].toLowerCase();
                        const score = keywords.filter(k => lineLower.includes(k.toLowerCase())).length;
                        if (score > bestScore) { bestScore = score; bestLine = li; }
                    }
                    if (bestLine >= 0 && bestScore >= 1) {
                        matches.push({ start: lineOffsets[bestLine], end: lineOffsets[bestLine] + lines[bestLine].length, h });
                        continue;
                    }
                }
            }
            if (pos >= 0) {
                matches.push({ start: pos, end: pos + raw.length, h });
            } else {
                matches.push({ start: -1, end: -1, h });
            }
        }

        // Sort matched ranges by position, skip unmatched
        const matched = matches.filter(m => m.start >= 0).sort((a, b) => a.start - b.start);
        const unmatched = matches.filter(m => m.start < 0);

        // Build HTML from raw text with <mark> insertions
        let html = '';
        let cursor = 0;
        for (const m of matched) {
            if (m.start < cursor) continue; // overlapping, skip
            html += _escHtml(text.substring(cursor, m.start));
            const color = m.h.severity === 'HIGH' ? '#fecaca' : '#fef08a';
            const borderColor = m.h.severity === 'HIGH' ? '#f87171' : '#facc15';
            html += `<mark class="gate-mark" data-section-idx="${sectionIdx}" data-reason-idx="${m.h.reasonIdx}" style="background:${color};border-bottom:2px solid ${borderColor};padding:1px 2px;border-radius:2px;cursor:pointer;">`;
            html += _escHtml(text.substring(m.start, m.end));
            html += '</mark>';
            cursor = m.end;
        }
        html += _escHtml(text.substring(cursor));

        // Collect unmatched reason indices (failed matches + reasons without location_hint)
        const unmatchedReasonIndices = [...unmatched.map(m => m.h.reasonIdx), ...noHintIndices];

        return { html: `<pre style="white-space:pre-wrap;font-family:inherit;margin:0;line-height:1.8;">${html}</pre>`, unmatchedReasonIndices };
    }

    function _escHtml(s) {
        return s.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;').replace(/"/g,'&quot;');
    }
    function _escAttr(s) {
        return s.replace(/&/g,'&amp;').replace(/"/g,'&quot;').replace(/</g,'&lt;').replace(/>/g,'&gt;');
    }

    // â”€â”€ Gate Popover â”€â”€
    let _gatePopoverEl = null;

    function _ensurePopoverEl() {
        if (_gatePopoverEl) return _gatePopoverEl;
        const div = document.createElement('div');
        div.className = 'gate-popover';
        div.innerHTML = `<div class="gate-popover-arrow arrow-top" style="left:20px;"></div>
            <div class="gate-popover-body"></div>`;
        document.body.appendChild(div);
        _gatePopoverEl = div;
        return div;
    }

    function showGatePopover(markEl) {
        const sIdx = parseInt(markEl.dataset.sectionIdx);
        const rIdx = parseInt(markEl.dataset.reasonIdx);
        const textarea = document.getElementById(`editor-${sIdx}`);
        if (!textarea) return;
        let reasons = [];
        try {
            let raw = textarea.dataset.gateReasons || '[]';
            reasons = JSON.parse(raw);
            if (typeof reasons === 'string') reasons = JSON.parse(reasons);
        } catch(e) { return; }
        const r = reasons[rIdx];
        if (!r) return;

        const pop = _ensurePopoverEl();
        const body = pop.querySelector('.gate-popover-body');
        const sevColor = r.severity === 'HIGH' ? '#dc2626' : '#d97706';
        const sevBg = r.severity === 'HIGH' ? '#fef2f2' : '#fffbeb';
        const typeLabel = r.type || 'ISSUE';
        const sevLabel = r.severity || 'MEDIUM';
        const suggestionHTML = r.fix_suggestion
            ? `<div style="font-size:12px;color:#2563eb;margin:6px 0;padding:4px 8px;background:#eff6ff;border-radius:4px;">ğŸ’¡ ${_escHtml(r.fix_suggestion)}</div>`
            : '';
        const applyBtn = r.fix_suggestion
            ? `<button onclick="applyGateSuggestionFromPopover(${sIdx},${rIdx})" style="padding:4px 12px;border:none;border-radius:4px;background:#2563eb;color:white;cursor:pointer;font-size:12px;">ì œì•ˆ ì ìš©</button>`
            : '';

        body.innerHTML = `
            <div style="display:inline-block;padding:2px 8px;border-radius:4px;font-size:11px;font-weight:700;background:${sevBg};color:${sevColor};margin-bottom:6px;">${_escHtml(typeLabel)} Â· ${sevLabel}</div>
            <div style="font-size:13px;margin:4px 0;">${_escHtml(r.message || '')}</div>
            ${suggestionHTML}
            <hr style="border:none;border-top:1px solid #e5e7eb;margin:8px 0;">
            <div style="display:flex;justify-content:flex-end;gap:6px;">
                ${applyBtn}
                <button onclick="dismissGateReasonFromPopover(${sIdx},${rIdx})" style="padding:4px 12px;border:1px solid #d1d5db;border-radius:4px;background:#fff;color:#374151;cursor:pointer;font-size:12px;">ë¬´ì‹œ</button>
            </div>`;

        pop.style.display = 'block';
        positionPopover(pop, markEl);
    }

    function hideGatePopover() {
        if (_gatePopoverEl) _gatePopoverEl.style.display = 'none';
    }

    function positionPopover(popover, markEl) {
        const markRect = markEl.getBoundingClientRect();
        const popRect = popover.getBoundingClientRect();
        const arrow = popover.querySelector('.gate-popover-arrow');
        const scrollY = window.scrollY || document.documentElement.scrollTop;
        const scrollX = window.scrollX || document.documentElement.scrollLeft;

        // Prefer below
        let top = markRect.bottom + scrollY + 8;
        let left = markRect.left + scrollX;
        let arrowOnTop = true;

        // If not enough space below, show above
        if (markRect.bottom + popRect.height + 16 > window.innerHeight) {
            top = markRect.top + scrollY - popRect.height - 8;
            arrowOnTop = false;
        }

        // Clamp horizontal
        if (left + popRect.width > window.innerWidth + scrollX - 8) {
            left = window.innerWidth + scrollX - popRect.width - 8;
        }
        if (left < scrollX + 8) left = scrollX + 8;

        popover.style.top = top + 'px';
        popover.style.left = left + 'px';

        // Arrow position
        arrow.className = 'gate-popover-arrow ' + (arrowOnTop ? 'arrow-top' : 'arrow-bottom');
        const arrowLeft = Math.max(12, Math.min(markRect.left + scrollX - left + markRect.width / 2 - 5, popRect.width - 20));
        arrow.style.left = arrowLeft + 'px';
    }

    // Global listeners for popover
    document.addEventListener('click', function(e) {
        const mark = e.target.closest('.gate-mark');
        if (mark) {
            e.preventDefault();
            e.stopPropagation();
            showGatePopover(mark);
            return;
        }
        if (_gatePopoverEl && !e.target.closest('.gate-popover')) {
            hideGatePopover();
        }
    });

    document.addEventListener('keydown', function(e) {
        if (e.key === 'Escape') hideGatePopover();
    });

    // Close popover on editor-body scroll (use capture to catch scroll in nested elements)
    document.addEventListener('scroll', function(e) {
        if (e.target.closest && (e.target.closest('.editor-body') || e.target.closest('.highlight-preview'))) {
            hideGatePopover();
        }
    }, true);

    function toggleMoreBtns(idx) {
        const el = document.getElementById(`more-btns-${idx}`);
        if (!el) return;
        el.style.display = el.style.display === 'none' ? 'inline-flex' : 'none';
    }

    function _startLamp(label) {
        const lamp = document.getElementById('manualize-status');
        const timerEl = document.getElementById('manualize-timer');
        if (lamp) { lamp.style.display = 'inline'; lamp.style.cssText = ''; lamp.textContent = label; }
        const start = Date.now();
        let iv = null;
        if (timerEl) {
            timerEl.style.display = 'inline';
            iv = setInterval(() => {
                const s = (Date.now() - start) / 1000;
                const m = Math.floor(s / 60);
                const sec = (s % 60).toFixed(1);
                timerEl.textContent = m > 0 ? `${m}:${sec.padStart(4,'0')}` : `${sec}s`;
            }, 100);
        }
        return { lamp, timerEl, start, iv };
    }
    function _stopLamp(ctx, resultText, isError) {
        if (ctx.iv) clearInterval(ctx.iv);
        const _raw = (Date.now() - ctx.start) / 1000;
        const _m = Math.floor(_raw / 60);
        const _s = (_raw % 60).toFixed(1);
        const elapsed = _m > 0 ? `${_m}ë¶„ ${_s}ì´ˆ` : `${_s}ì´ˆ`;
        if (ctx.timerEl) ctx.timerEl.style.display = 'none';
        if (ctx.lamp) {
            ctx.lamp.className = '';
            ctx.lamp.textContent = `${resultText} Â· ${elapsed}`;
            ctx.lamp.style.cssText = isError
                ? 'display:inline;background:#fecaca;color:#991b1b;padding:2px 10px;border-radius:8px;font-size:12px;font-weight:700;'
                : 'display:inline;background:#dcfce7;color:#166534;padding:2px 10px;border-radius:8px;font-size:12px;font-weight:700;';
            if (!isError) setTimeout(() => { ctx.lamp.style.display = 'none'; ctx.lamp.style.cssText = ''; ctx.lamp.className = 'manualize-lamp'; }, 8000);
        }
    }

    function _getSections() {
        const tas = document.getElementById('editor-container').querySelectorAll('textarea.editor-textarea');
        const list = [];
        let totalChars = 0;
        tas.forEach((ta, idx) => {
            list.push({ idx, name: ta.dataset.sectionName, text: ta.value, ta });
            totalChars += ta.value.length;
        });
        return { list, totalChars };
    }

    async function _runParallel(items, concurrency, fn, onProgress) {
        let done = 0, failed = 0;
        const results = new Array(items.length);
        let idx = 0;
        async function worker() {
            while (idx < items.length) {
                const i = idx++;
                try {
                    results[i] = await fn(items[i]);
                } catch(e) { results[i] = { error: e }; failed++; }
                done++;
                if (onProgress) onProgress(done, failed);
            }
        }
        await Promise.all(Array.from({ length: Math.min(concurrency, items.length) }, () => worker()));
        return { results, done, failed };
    }

    function _enableBtn(id, label) {
        const b = document.getElementById(id);
        if (b) { b.disabled = false; b.style.opacity = '1'; b.style.cursor = 'pointer'; if (label) b.textContent = label; }
    }
    function _disableBtn(id, label) {
        const b = document.getElementById(id);
        if (b) { b.disabled = true; b.style.opacity = '0.4'; b.style.cursor = 'not-allowed'; if (label) b.textContent = label; }
    }

    function _markAllPhase(phase, count) {
        for (let i = 0; i < count; i++) _markSectionPhase(i, phase);
    }

    function _markSectionPhase(idx, phase) {
        const badge = document.getElementById(`phase-done-${idx}`);
        if (!badge) return;
        badge.style.display = 'inline';
        badge.classList.remove('badge-working');
        if (phase === 1) { badge.textContent = 'â‘  ì™„ë£Œ'; badge.style.background = '#dcfce7'; badge.style.color = '#166534'; }
        else if (phase === 2) { badge.textContent = 'â‘¡ ì™„ë£Œ'; badge.style.background = '#ede9fe'; badge.style.color = '#5b21b6'; }
        else if (phase === 3) { badge.textContent = 'â‘¢ ì™„ë£Œ'; badge.style.background = '#fef9c3'; badge.style.color = '#854d0e'; }
        // ì¹´ë“œ ë°ê²Œ ë³µì›
        const card = document.getElementById(`section-card-${idx}`);
        if (card) { card.style.opacity = '1'; }
    }

    function _markSectionWorking(idx, label) {
        const badge = document.getElementById(`phase-done-${idx}`);
        if (!badge) return;
        badge.style.display = 'inline';
        badge.textContent = label;
        badge.style.background = '#fef3c7';
        badge.style.color = '#92400e';
        badge.classList.add('badge-working');
        // ì¹´ë“œ ë°ê²Œ (ì§„í–‰ ì¤‘)
        const card = document.getElementById(`section-card-${idx}`);
        if (card) { card.style.opacity = '1'; }
    }

    function _dimAllSections(count) {
        for (let i = 0; i < count; i++) {
            const card = document.getElementById(`section-card-${i}`);
            if (card) { card.style.opacity = '0.45'; card.style.boxShadow = ''; }
        }
    }

    function _markSectionBtnDone(idx, task) {
        if (task === 'fill') {
            const btn = document.getElementById(`btn-fill-${idx}`);
            if (btn) { btn.textContent = 'â‘  ë§¥ë½ ë³´ê°• âœ“'; btn.style.outline = '2px solid #22c55e'; btn.style.outlineOffset = '-2px'; }
        }
        if (task === 'refine') {
            const btn = document.getElementById(`btn-refine-${idx}`);
            if (btn) { btn.textContent = 'â‘¡ RAG ìµœì í™” âœ“'; btn.style.outline = '2px solid #22c55e'; btn.style.outlineOffset = '-2px'; }
        }
    }

    function _restorePhases(phasesStr, sectionCount) {
        if (!phasesStr) return;
        const phases = phasesStr.split(',');
        let maxPhase = 0;
        if (phases.includes('fill')) {
            maxPhase = 1;
            _markBtnDone('btn-fill-all', 'â‘  ë§¥ë½ ë³´ê°•(ì „ì²´) âœ“');
            for (let i = 0; i < sectionCount; i++) _markSectionBtnDone(i, 'fill');
        }
        if (phases.includes('refine')) {
            maxPhase = 2;
            _markBtnDone('btn-refine-all', 'â‘¡ RAG ìµœì í™”(ì „ì²´) âœ“');
            for (let i = 0; i < sectionCount; i++) _markSectionBtnDone(i, 'refine');
        }
        if (phases.includes('gate')) {
            _markBtnDone('btn-gate-all', 'â‘¢ Gate(ì „ì²´) âœ“');
            for (let i = 0; i < sectionCount; i++) {
                const gateBtn = document.getElementById(`btn-gate-${i}`);
                if (gateBtn) { gateBtn.textContent = 'â‘¢ Gate ê²€ì¦ âœ“'; gateBtn.style.outline = '2px solid #22c55e'; gateBtn.style.outlineOffset = '-2px'; }
            }
        }
        if (maxPhase > 0) _markAllPhase(maxPhase, sectionCount);
    }

    function _markBtnDone(id, label) {
        const b = document.getElementById(id);
        if (!b) return;
        b.disabled = false;
        b.style.opacity = '1';
        b.style.cursor = 'pointer';
        b.textContent = label;
        b.style.outline = '2px solid #22c55e';
        b.style.outlineOffset = '-2px';
    }

    async function _savePhase(docId, phase) {
        try {
            await fetch(`/api/doc/${docId}/completed-phase`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ phase })
            });
        } catch(e) { console.warn('[SAVE_PHASE]', e); }
    }

    async function _snapshotAiText(docId) {
        try {
            await fetch(`/api/doc/${docId}/snapshot-ai-text`, { method: 'POST' });
        } catch(e) { console.warn('[SNAPSHOT_AI]', e); }
    }

    async function _snapshotAiTextSection(docId, sectionName) {
        try {
            await fetch(`/api/doc/${docId}/snapshot-ai-text-section`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ section_name: sectionName })
            });
        } catch(e) { console.warn('[SNAPSHOT_AI_SEC]', e); }
    }

    async function fillAll() {
        if (!confirm('ëª¨ë“  ì„¹ì…˜ì— ë§¥ë½ ë³´ê°•(â‘ )ì„ ì‹¤í–‰í•©ë‹ˆë‹¤. ì§„í–‰í•˜ì‹œê² ìŠµë‹ˆê¹Œ?')) return;
        _disableBtn('btn-fill-all', 'â‘  ë³´ê°• ì¤‘...');

        const { list, totalChars } = _getSections();
        const total = list.length;
        const charsLabel = totalChars > 0 ? `${totalChars.toLocaleString()}ì` : '';
        const ctx = _startLamp(`â‘  ë§¥ë½ ë³´ê°• ì¤‘... ${charsLabel} Â· 0/${total}`);
        _dimAllSections(total);

        try {
            await saveEditor(true);
            const { done, failed } = await _runParallel(list, 3, async (sec) => {
                _markSectionWorking(sec.idx, 'â‘  ì§„í–‰ ì¤‘â€¦');
                const res = await fetch(`/api/doc/${currentDocId}/refine-text`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ text: sec.text, task: 'fill', context: sec.name, allow_qa: 'false' })
                });
                if (res.ok) {
                    const data = await res.json();
                    if (data.suggestion) { sec.ta.value = data.suggestion; autoResize(sec.ta); sec._aiModified = true; }
                    _markSectionPhase(sec.idx, 1);
                } else { throw new Error(`HTTP ${res.status}`); }
            }, (d, f) => {
                if (ctx.lamp) ctx.lamp.textContent = `â‘  ë§¥ë½ ë³´ê°• ì¤‘... ${charsLabel} Â· ${d}/${total}`;
            });
            await saveEditor(true);
            // AIê°€ ìˆ˜ì •í•œ ì„¹ì…˜ë§Œ ê°œë³„ snapshot
            for (const sec of list) {
                if (sec._aiModified) await _snapshotAiTextSection(currentDocId, sec.name);
            }
            await _savePhase(currentDocId, 'fill');
            _markBtnDone('btn-fill-all', 'â‘  ë§¥ë½ ë³´ê°•(ì „ì²´) âœ“');
            _stopLamp(ctx, `ë§¥ë½ ë³´ê°• ì™„ë£Œ Â· ${done - failed}/${total}ê°œ Â· ${charsLabel}`, false);
            // Refresh editor to show updated text
            await openEditor(currentDocId);
        } catch(e) {
            console.error('[FILL_ALL]', e);
            _stopLamp(ctx, 'ë§¥ë½ ë³´ê°• ì‹¤íŒ¨', true);
            alert('ë§¥ë½ ë³´ê°• ì˜¤ë¥˜: ' + e.message);
            _enableBtn('btn-fill-all', 'â‘  ë§¥ë½ ë³´ê°•(ì „ì²´)');
        }
    }

    async function refineAll() {
        if (!confirm('ëª¨ë“  ì„¹ì…˜ì— RAG ìµœì í™”(â‘¡)ë¥¼ ì‹¤í–‰í•©ë‹ˆë‹¤. ì§„í–‰í•˜ì‹œê² ìŠµë‹ˆê¹Œ?')) return;
        _disableBtn('btn-refine-all', 'â‘¡ ìµœì í™” ì¤‘...');

        const { list, totalChars } = _getSections();
        const total = list.length;
        const charsLabel = totalChars > 0 ? `${totalChars.toLocaleString()}ì` : '';
        const ctx = _startLamp(`â‘¡ RAG ìµœì í™” ì¤‘... ${charsLabel} Â· 0/${total}`);
        _dimAllSections(total);

        try {
            await saveEditor(true);
            const { done, failed } = await _runParallel(list, 3, async (sec) => {
                _markSectionWorking(sec.idx, 'â‘¡ ì§„í–‰ ì¤‘â€¦');
                const res = await fetch(`/api/doc/${currentDocId}/refine-text`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ text: sec.text, task: 'refine', context: sec.name })
                });
                if (res.ok) {
                    const data = await res.json();
                    if (data.suggestion) { sec.ta.value = data.suggestion; autoResize(sec.ta); sec._aiModified = true; }
                    _markSectionPhase(sec.idx, 2);
                } else { throw new Error(`HTTP ${res.status}`); }
            }, (d, f) => {
                if (ctx.lamp) ctx.lamp.textContent = `â‘¡ RAG ìµœì í™” ì¤‘... ${charsLabel} Â· ${d}/${total}`;
            });
            await saveEditor(true);
            // AIê°€ ìˆ˜ì •í•œ ì„¹ì…˜ë§Œ ê°œë³„ snapshot
            for (const sec of list) {
                if (sec._aiModified) await _snapshotAiTextSection(currentDocId, sec.name);
            }
            await _savePhase(currentDocId, 'refine');
            _markBtnDone('btn-refine-all', 'â‘¡ RAG ìµœì í™”(ì „ì²´) âœ“');
            _stopLamp(ctx, `RAG ìµœì í™” ì™„ë£Œ Â· ${done - failed}/${total}ê°œ Â· ${charsLabel}`, false);
            // Refresh editor to show updated text
            await openEditor(currentDocId);
        } catch(e) {
            console.error('[REFINE_ALL]', e);
            _stopLamp(ctx, 'RAG ìµœì í™” ì‹¤íŒ¨', true);
            alert('RAG ìµœì í™” ì˜¤ë¥˜: ' + e.message);
            _enableBtn('btn-refine-all', 'â‘¡ RAG ìµœì í™”(ì „ì²´)');
        }
    }

    async function gateAll() {
        if (!confirm('ëª¨ë“  ì„¹ì…˜ì— Gate ê²€ì¦(â‘¢)ì„ ì‹¤í–‰í•©ë‹ˆë‹¤. ì§„í–‰í•˜ì‹œê² ìŠµë‹ˆê¹Œ?')) return;
        _disableBtn('btn-gate-all', 'â‘¢ ê²€ì¦ ì¤‘...');

        const { list, totalChars } = _getSections();
        const charsLabel = totalChars > 0 ? `${totalChars.toLocaleString()}ì` : '';
        const ctx = _startLamp(`â‘¢ Gate ê²€ì¦ ì¤‘... ${charsLabel} Â· 0/${list.length}`);
        _dimAllSections(list.length);
        let pass_count = 0, need_fix = 0, block = 0;

        try {
            await saveEditor(true);
            let totalGateTime = 0;
            const { done, failed } = await _runParallel(list, 3, async (sec) => {
                _markSectionWorking(sec.idx, 'â‘¢ ê²€ì¦ ì¤‘â€¦');
                const res = await fetch(`/api/doc/${currentDocId}/section/${encodeURIComponent(sec.name)}/gate`, { method: 'POST' });
                if (res.ok) {
                    const data = await res.json();
                    const st = data.status || 'PASS';
                    if (st === 'PASS') pass_count++;
                    else if (st === 'NEED_FIX') need_fix++;
                    else if (st === 'BLOCK') block++;
                    if (data.time_s) totalGateTime += data.time_s;
                    // Update section gate UI
                    updateSectionGateUI(sec.idx, st);
                    _markSectionPhase(sec.idx, 3);
                }
            }, (d, f) => {
                if (ctx.lamp) ctx.lamp.textContent = `â‘¢ Gate ê²€ì¦ ì¤‘... ${charsLabel} Â· ${d}/${list.length}`;
            });
            // Stop lamp immediately after all sections done
            _markBtnDone('btn-gate-all', 'â‘¢ Gate(ì „ì²´) âœ“');
            _stopLamp(ctx, `Gate ì™„ë£Œ Â· PASS ${pass_count} / NEED_FIX ${need_fix} / BLOCK ${block} Â· ${totalGateTime.toFixed(1)}s`, false);
            // ë¦¬ìŠ¤íŠ¸ RAG ë°ì´í„°í™” ë²„íŠ¼: ì „ì²´ PASSì¼ ë•Œë§Œ í™œì„±í™”
            const approveBtn = document.getElementById(`approve-btn-${currentDocId}`);
            if (approveBtn) {
                const allSectionsPass = need_fix === 0 && block === 0 && pass_count > 0;
                if (allSectionsPass) { approveBtn.disabled = false; approveBtn.style.opacity = '1'; approveBtn.style.cursor = 'pointer'; }
                else { approveBtn.disabled = true; approveBtn.style.opacity = '0.4'; approveBtn.style.cursor = 'not-allowed'; }
            }
            // Post-processing (non-blocking, fail-safe)
            _savePhase(currentDocId, 'gate');
            openEditor(currentDocId).catch(e => console.warn('[GATE_ALL] editor refresh failed:', e));
        } catch(e) {
            console.error('[GATE_ALL]', e);
            _stopLamp(ctx, 'Gate ê²€ì¦ ì‹¤íŒ¨', true);
            alert('Gate ê²€ì¦ ì˜¤ë¥˜: ' + e.message);
            _enableBtn('btn-gate-all', 'â‘¢ Gate(ì „ì²´)');
        }
    }

    async function publishAll() {
        if (!confirm('PASS ì„¹ì…˜ë§Œ RAGì— ë°˜ì˜í•©ë‹ˆë‹¤. ì§„í–‰í•˜ì‹œê² ìŠµë‹ˆê¹Œ?')) return;
        const btn = document.getElementById('btn-publish-all');
        if (btn) { btn.disabled = true; btn.textContent = 'ğŸ“¦ RAG ë°˜ì˜ ì¤‘...'; }
        const ctx = _startLamp('ğŸ“¦ RAG ë°˜ì˜ ì¤‘...');

        try {
            await saveEditor(true);
            const res = await fetch(`/api/doc/${currentDocId}/publish-all`, { method: 'POST' });
            const text = await res.text();
            if (!res.ok) {
                _stopLamp(ctx, 'RAG ë°˜ì˜ ì‹¤íŒ¨', true);
                let detail; try { detail = JSON.parse(text).detail; } catch(_) { detail = text; }
                alert('RAG ë°˜ì˜ ì‹¤íŒ¨: ' + (detail || `HTTP ${res.status}`));
                return;
            }
            const data = JSON.parse(text);
            _stopLamp(ctx, `RAG ë°˜ì˜ ì™„ë£Œ Â· ${data.published_count}ê°œ ë°˜ì˜ Â· ${data.excluded_count}ê°œ ì œì™¸`, false);
            // ë°˜ì˜/ì œì™¸ ëª©ë¡ ëª¨ë‹¬
            const pubList = (data.published_names || []).map(n => `<li style="color:#166534;">âœ… ${n}</li>`).join('');
            const exList = (data.excluded_names || []).map(n => `<li style="color:#991b1b;">â›” ${n}</li>`).join('');
            const failList = (data.failed_sections || []).map(f => `<li style="color:#dc2626;">âŒ ${f.section_name}: ${f.reason}</li>`).join('');
            showModal('ğŸ“¦ RAG ë°˜ì˜ ê²°ê³¼',
                `<div style="text-align:left;font-size:14px;">` +
                (pubList ? `<strong>ë°˜ì˜ë¨ (${data.published_count})</strong><ul style="margin:4px 0 12px 1.2rem;">${pubList}</ul>` : '') +
                (exList ? `<strong>ì œì™¸ë¨ (${data.excluded_count})</strong><ul style="margin:4px 0 12px 1.2rem;">${exList}</ul>` : '') +
                (failList ? `<strong>ì‹¤íŒ¨ (${data.failed_count})</strong><ul style="margin:4px 0 12px 1.2rem;">${failList}</ul>` : '') +
                `</div>`
            );
            // ë¦¬ìŠ¤íŠ¸ ìƒíƒœ ë°°ì§€ ì—…ë°ì´íŠ¸
            const row = document.getElementById(`row-${currentDocId}`);
            if (row) {
                const badge = row.querySelector('.badge');
                if (badge) { badge.className = 'badge badge-approved'; badge.textContent = 'APPROVED'; }
            }
            await openEditor(currentDocId);
        } catch(e) {
            console.error('[PUBLISH_ALL]', e);
            _stopLamp(ctx, 'RAG ë°˜ì˜ ì‹¤íŒ¨', true);
            alert('RAG ë°˜ì˜ ì˜¤ë¥˜: ' + e.message);
        } finally {
            if (btn) { btn.disabled = false; btn.textContent = 'ğŸ“¦ RAG ë°˜ì˜'; }
        }
    }

    async function saveEditor(silent = false) {
        const container = document.getElementById('editor-container');
        const textareas = container.querySelectorAll('textarea.editor-textarea');
        const sections = {};
        textareas.forEach(ta => {
            const name = ta.dataset.sectionName;
            if (name) sections[name] = ta.value;
        });

        try {
            const res = await fetch(`/api/doc/${currentDocId}/sections`, {
                method: 'PUT',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ sections })
            });

            if (res.ok) {
                if (!silent) alert("ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤.");
            } else {
                const errText = await res.text();
                let errMsg;
                try { errMsg = JSON.parse(errText).detail; } catch(_) { errMsg = errText; }
                if (!silent) alert("ì €ì¥ ì‹¤íŒ¨: " + (errMsg || `HTTP ${res.status}`));
            }
        } catch(e) {
            if (!silent) alert("ì €ì¥ ì‹¤íŒ¨: " + e.message);
        }
    }

    async function revalidateEditor() {
        await saveEditor();
        qualityGate(currentDocId);
    }

    async function apiCall(endpoint, method = 'POST') {
        try {
            const res = await fetch(endpoint, { method });
            const data = await res.json();
            return { ok: res.ok, data };
        } catch (e) {
            return { ok: false, data: { error: e.message } };
        }
    }

    function showModal(title, content) {
        document.getElementById('modal-title').textContent = title;
        const body = document.getElementById('modal-body');
        if (typeof content === 'string' && content.includes('<div')) {
            body.innerHTML = content;
        } else {
            body.innerHTML = `<pre style="background:#f5f5f5;padding:1rem;border-radius:4px;white-space:pre-wrap;word-break:break-word;">${typeof content === 'string' ? content : JSON.stringify(content, null, 2)}</pre>`;
        }
        const btnArea = document.getElementById('modal-buttons');
        btnArea.innerHTML = '';
        btnArea.style.display = 'none';
        document.getElementById('result-modal').style.display = 'flex';
    }

    function closeModal() {
        document.getElementById('result-modal').style.display = 'none';
        document.getElementById('modal-buttons').innerHTML = '';
        document.getElementById('modal-buttons').style.display = 'none';
    }

    async function extractText(docId, resumePage = 0) {
        // ê¸°ì¡´ raw_text í™•ì¸ + ì´ì „ ì¤‘ë‹¨ ì •ë³´ í™•ì¸
        if (resumePage === 0) {
            try {
                const [ccRes, pRes] = await Promise.all([
                    fetch(`/api/doc/${docId}/char-count`),
                    fetch(`/api/doc/${docId}/extract-progress`)
                ]);
                const cc = await ccRes.json();
                const prog = await pRes.json();
                const lastPage = prog.page || 0;
                const totalPages = prog.total_pages || 0;
                const wasCancelled = prog.cancelled || false;

                if (cc.chars > 0) {
                    const modalBody = document.getElementById('modal-body');
                    const modalTitle = document.getElementById('modal-title');
                    modalTitle.textContent = 'í…ìŠ¤íŠ¸ ì¶”ì¶œ';

                    // ì¤‘ë‹¨ëœ ìƒíƒœê°€ ìˆìœ¼ë©´ ì´ì–´í•˜ê¸° ì˜µì…˜ í‘œì‹œ
                    if (wasCancelled && lastPage > 0 && lastPage < totalPages) {
                        modalBody.innerHTML = `
                            <div style="text-align:center;padding:20px;">
                                <p style="margin-bottom:8px;color:#374151;">ê¸°ì¡´ ì¶”ì¶œëœ í…ìŠ¤íŠ¸ê°€ ìˆìŠµë‹ˆë‹¤ (${cc.chars.toLocaleString()}ì)</p>
                                <p style="margin-bottom:16px;color:#6b7280;font-size:13px;">ì´ì „ ì¶”ì¶œ: ${lastPage}/${totalPages} í˜ì´ì§€ì—ì„œ ì¤‘ë‹¨ë¨</p>
                                <div style="display:flex;gap:10px;justify-content:center;">
                                    <button id="extract-restart-btn" style="padding:8px 20px;border-radius:8px;font-size:13px;border:1px solid #d1d5db;background:#fff;color:#374151;cursor:pointer;">ì²˜ìŒë¶€í„° ë‹¤ì‹œ</button>
                                    <button id="extract-resume-btn" style="padding:8px 20px;border-radius:8px;font-size:13px;border:none;background:#6366f1;color:#fff;cursor:pointer;">ì´ì–´ì„œ ì¶”ì¶œ (${lastPage + 1}p~)</button>
                                </div>
                            </div>`;
                        document.getElementById('modal-buttons').style.display = 'none';
                        document.getElementById('result-modal').style.display = 'flex';
                        document.getElementById('extract-restart-btn').onclick = () => { _doExtract(docId, 0); };
                        document.getElementById('extract-resume-btn').onclick = () => { _doExtract(docId, lastPage + 1); };
                        return;
                    } else {
                        // ì™„ë£Œëœ ìƒíƒœ â€” ë‹¤ì‹œ í• ì§€ë§Œ í™•ì¸
                        modalBody.innerHTML = `
                            <div style="text-align:center;padding:20px;">
                                <p style="margin-bottom:16px;color:#374151;">ê¸°ì¡´ ì¶”ì¶œëœ í…ìŠ¤íŠ¸ê°€ ìˆìŠµë‹ˆë‹¤ (${cc.chars.toLocaleString()}ì)<br><span style="font-size:12px;color:#9ca3af;">ë‹¤ì‹œ ì¶”ì¶œí•˜ë©´ ê¸°ì¡´ ë‚´ìš©ì´ ë®ì–´ì”Œì›Œì§‘ë‹ˆë‹¤</span></p>
                                <div style="display:flex;gap:10px;justify-content:center;">
                                    <button id="extract-cancel-choice" style="padding:8px 20px;border-radius:8px;font-size:13px;border:1px solid #d1d5db;background:#fff;color:#374151;cursor:pointer;">ì·¨ì†Œ</button>
                                    <button id="extract-restart-btn" style="padding:8px 20px;border-radius:8px;font-size:13px;border:none;background:#6366f1;color:#fff;cursor:pointer;">ë‹¤ì‹œ ì¶”ì¶œ</button>
                                </div>
                            </div>`;
                        document.getElementById('modal-buttons').style.display = 'none';
                        document.getElementById('result-modal').style.display = 'flex';
                        document.getElementById('extract-cancel-choice').onclick = () => { closeModal(); };
                        document.getElementById('extract-restart-btn').onclick = () => { _doExtract(docId, 0); };
                        return;
                    }
                }
            } catch(e) {}
        }
        _doExtract(docId, resumePage);
    }

    async function _doExtract(docId, resumePage) {
        let resumeParam = resumePage > 0 ? `?resume_page=${resumePage}` : '';

        const modalBody = document.getElementById('modal-body');
        const modalTitle = document.getElementById('modal-title');
        modalTitle.textContent = resumeParam ? 'í…ìŠ¤íŠ¸ ì¶”ì¶œ ì´ì–´í•˜ê¸°...' : 'í…ìŠ¤íŠ¸ ì¶”ì¶œ ì¤‘...';
        modalBody.innerHTML = `
            <div id="extract-header" style="display:flex;align-items:center;gap:10px;margin-bottom:12px;">
                <div class="spinner"></div>
                <span id="extract-progress-text" style="font-size:13px;color:#6b7280;">ë¬¸ì„œì—ì„œ ë‚´ìš©ì„ ì½ì–´ì˜¤ê³  ìˆìŠµë‹ˆë‹¤...</span>
                <button id="extract-cancel-btn" style="margin-left:auto;padding:4px 14px;border-radius:8px;font-size:12px;border:1px solid #fca5a5;background:#fff;color:#dc2626;cursor:pointer;z-index:10;">âœ• ì·¨ì†Œ</button>
            </div>
            <div id="extract-pages" style="max-height:60vh;overflow-y:auto;display:flex;flex-direction:column;gap:8px;"></div>
        `;
        document.getElementById('modal-buttons').style.display = 'none';
        document.getElementById('result-modal').style.display = 'flex';

        const abortCtrl = new AbortController();
        document.getElementById('extract-cancel-btn').addEventListener('click', async () => {
            try { await fetch(`/api/doc/${docId}/extract-cancel`, { method: 'POST' }); } catch(e) {}
            abortCtrl.abort();
        });

        // Poll extract progress + stream pages
        const progressEl = document.getElementById('extract-progress-text');
        const pagesEl = document.getElementById('extract-pages');
        let renderedPages = new Set();
        let lastPage = 0;
        const progressIv = setInterval(async () => {
            try {
                const pRes = await fetch(`/api/doc/${docId}/extract-progress`);
                const p = await pRes.json();
                if (p.page) lastPage = p.page;
                if (p.status && progressEl) {
                    let detail = p.status;
                    if (p.total_pages > 0) detail = `${p.page}/${p.total_pages} í˜ì´ì§€`;
                    if (p.images_total > 0) detail += ` Â· ì´ë¯¸ì§€ ${p.images_done}/${p.images_total}`;
                    progressEl.textContent = detail;
                }
                // Stream pages as they arrive
                if (p.pages && pagesEl) {
                    for (const [pageKey, content] of Object.entries(p.pages)) {
                        if (renderedPages.has(pageKey)) continue;
                        renderedPages.add(pageKey);
                        const card = document.createElement('div');
                        card.style.cssText = 'background:#f9fafb;border:1px solid #e5e7eb;border-radius:8px;padding:12px;';
                        const preview = content.length > 500 ? content.substring(0, 500) + '...' : content;
                        card.innerHTML = `<div style="font-weight:600;font-size:13px;color:#4b5563;margin-bottom:6px;">ğŸ“„ ${pageKey}</div><pre style="white-space:pre-wrap;word-break:break-word;font-size:12px;color:#374151;margin:0;max-height:200px;overflow-y:auto;">${preview.replace(/</g,'&lt;')}</pre>`;
                        pagesEl.appendChild(card);
                        pagesEl.scrollTop = pagesEl.scrollHeight;
                    }
                }
            } catch(e) {}
        }, 1500);

        try {
            const res = await fetch(`/api/doc/${docId}/extract-text${resumeParam}`, { method: 'POST', signal: abortCtrl.signal });
            const data = await res.json();
            clearInterval(progressIv);

            if (res.ok && data.success) {
                const header = document.getElementById('extract-header');
                if (header) {
                    const imgInfo = data.image_count > 0 ? ` Â· ì´ë¯¸ì§€ ${data.image_count}ê±´` : '';
                    const resumeInfo = data.resumed_from ? ` (${data.resumed_from}í˜ì´ì§€ë¶€í„° ì´ì–´ì„œ)` : '';
                    header.innerHTML = `<span style="font-size:14px;font-weight:600;color:#059669;">âœ“ ì¶”ì¶œ ì™„ë£Œ â€” ${data.chars.toLocaleString()}ì${imgInfo}${resumeInfo}</span>`;
                }
                modalTitle.textContent = 'í…ìŠ¤íŠ¸ ì¶”ì¶œ ì™„ë£Œ';
            } else {
                showModal('ì˜¤ë¥˜', data.detail || data.error || 'ì¶”ì¶œ ì‹¤íŒ¨');
            }
        } catch(e) {
            clearInterval(progressIv);
            if (e.name === 'AbortError') {
                const header = document.getElementById('extract-header');
                if (header) {
                    header.innerHTML = `
                        <span style="font-size:14px;color:#dc2626;">âœ• ì¶”ì¶œ ì·¨ì†Œë¨</span>
                        <button id="extract-resume-after-cancel" style="margin-left:auto;padding:4px 14px;border-radius:8px;font-size:12px;border:1px solid #6366f1;background:#fff;color:#6366f1;cursor:pointer;">ì´ì–´ì„œ ì¬ì‹œì‘</button>
                    `;
                    const resumeBtn = document.getElementById('extract-resume-after-cancel');
                    if (resumeBtn) {
                        resumeBtn.onclick = () => extractText(docId, lastPage > 0 ? lastPage + 1 : 1);
                    }
                }
                modalTitle.textContent = 'ì¶”ì¶œ ì·¨ì†Œ';
            } else {
                showModal('ì˜¤ë¥˜', 'ë„¤íŠ¸ì›Œí¬ ì˜¤ë¥˜: ' + e.message);
            }
        }
    }

    function formatSections(details) {
        if (!details) return '';
        return Object.entries(details).map(([name, text]) => {
            const preview = text.length >= 300 ? text + '...' : text;
            return `ã€${name}ã€‘\n${preview}`;
        }).join('\n\n');
    }

    async function approve(docId) {
        showModal('RAG ë°ì´í„°í™” ì¤‘...', '<div style="text-align:center;"><div class="spinner"></div>ë¬¸ì„œë¥¼ ìŠ¹ì¸í•˜ê³  ê²€ìƒ‰ ì¸ë±ìŠ¤ë¥¼ ìƒì„± ì¤‘ì…ë‹ˆë‹¤...</div>');
        const { ok, data } = await apiCall(`/api/doc/${docId}/approve`);
        if (ok) {
            showModal('RAG ë°ì´í„°í™” ì™„ë£Œ', `ìƒíƒœ: ${data.status}\nì²­í¬ ìƒì„±: ${data.reindex.chunk_count}ê°œ\nì´ì œ ì±—ë´‡ì—ì„œ ê²€ìƒ‰ì´ ê°€ëŠ¥í•©ë‹ˆë‹¤.`);
            location.reload();
        } else {
            showModal('ì‹¤íŒ¨', data.detail || data.error);
        }
    }

    function showConfirmModal(title, content, onConfirm) {
        document.getElementById('modal-title').textContent = title;
        document.getElementById('modal-body').textContent = content;
        const btnArea = document.getElementById('modal-buttons');
        btnArea.innerHTML = `
            <button class="btn-small" style="background:#9ca3af;color:white;padding:8px 16px;border:none;border-radius:4px;cursor:pointer;" onclick="closeModal()">ì·¨ì†Œ (ê¸°ì¡´ ìœ ì§€)</button>
            <button class="btn-small" style="background:#8b5cf6;color:white;padding:8px 16px;border:none;border-radius:4px;cursor:pointer;" id="modal-confirm-btn">ë‹¤ì‹œ ë§¤ë‰´ì–¼í™” (LLM)</button>
        `;
        btnArea.style.display = 'flex';
        document.getElementById('modal-confirm-btn').onclick = () => { closeModal(); onConfirm(); };
        document.getElementById('result-modal').style.display = 'flex';
    }

    async function deleteApartment(aptId, aptName) {
        if (!confirm(`ì•„íŒŒíŠ¸ '${aptName}'ê³¼ ê´€ë ¨ëœ ëª¨ë“  ë¬¸ì„œ, RAG ë°ì´í„°, ëŒ€í™”ê°€ ì‚­ì œë©ë‹ˆë‹¤. ê³„ì†í•˜ì‹œê² ìŠµë‹ˆê¹Œ?`)) return;
        const res = await fetch(`/api/apartments/${aptId}`, { method: 'DELETE' });
        if (res.ok) { alert('ì‚­ì œë˜ì—ˆìŠµë‹ˆë‹¤.'); location.reload(); }
        else { const d = await res.json(); alert('ì‚­ì œ ì‹¤íŒ¨: ' + (d.detail || 'ì˜¤ë¥˜')); }
    }

    async function deleteDocument(docId, title) {
        if (!confirm(`ë¬¸ì„œ '${title}'ê³¼ ê´€ë ¨ëœ ëª¨ë“  ì„¹ì…˜, RAG ë°ì´í„°ê°€ ì‚­ì œë©ë‹ˆë‹¤. ê³„ì†í•˜ì‹œê² ìŠµë‹ˆê¹Œ?`)) return;
        const res = await fetch(`/api/doc/${docId}`, { method: 'DELETE' });
        if (res.ok) { alert('ì‚­ì œë˜ì—ˆìŠµë‹ˆë‹¤.'); location.reload(); }
        else { const d = await res.json(); alert('ì‚­ì œ ì‹¤íŒ¨: ' + (d.detail || 'ì˜¤ë¥˜')); }
    }

    let sourceMapCache = null;
    async function loadSourceMap() {
        if (sourceMapCache) return sourceMapCache;
        const res = await fetch(`/api/doc/${currentDocId}/source-map`);
        if (!res.ok) return null;
        sourceMapCache = await res.json();
        return sourceMapCache;
    }

    async function toggleSectionSource(idx) {
        const panel = document.getElementById(`source-panel-${idx}`);
        const row = document.getElementById(`section-row-${idx}`);
        const editorLabel = document.getElementById(`editor-label-${idx}`);
        const ta = document.getElementById(`editor-${idx}`);
        const hlDiv = document.getElementById(`highlight-${idx}`);
        if (!panel) return;

        if (panel.style.display !== 'none') {
            // ì›ë³¸ ë¹„êµ ë‹«ê¸°
            panel.style.display = 'none';
            row.classList.remove('section-row-compare');
            if (editorLabel) editorLabel.style.display = 'none';
            // ë†’ì´ ë³µì›: highlightê°€ ì¼œì ¸ ìˆìœ¼ë©´ ê·¸ê²ƒ ê¸°ì¤€, ì•„ë‹ˆë©´ textarea ê¸°ì¤€
            if (ta) {
                if (hlDiv && hlDiv.style.display !== 'none') {
                    // highlight ëª¨ë“œ â€” hlDiv ë†’ì´ë§Œ ìì—°ìŠ¤ëŸ½ê²Œ
                    hlDiv.style.height = '';
                } else {
                    ta.style.height = 'auto';
                    ta.style.height = ta.scrollHeight + 'px';
                }
            }
            return;
        }
        const data = await loadSourceMap();
        if (!data) { alert('ì›ë³¸ í…ìŠ¤íŠ¸ë¥¼ ë¶ˆëŸ¬ì˜¬ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.'); return; }
        const name = ta.dataset.sectionName;
        const matched = data.source_map[name];
        if (matched) {
            panel.innerHTML = `<div class="column-label">ì›ë³¸ í…ìŠ¤íŠ¸</div><div class="source-text">${escapeHtml(matched)}</div>`;
        } else {
            panel.innerHTML = `<div class="column-label" style="color:#dc2626;">ì›ë³¸ í…ìŠ¤íŠ¸ (ë§¤ì¹­ ì‹¤íŒ¨)</div><div class="source-text" style="color:#9ca3af;font-style:italic;">ì´ ì„¹ì…˜ì— ë§¤ì¹­ë˜ëŠ” ì›ë³¸ êµ¬ê°„ì„ ì°¾ì§€ ëª»í–ˆìŠµë‹ˆë‹¤.</div>`;
        }
        panel.style.display = 'block';
        row.classList.add('section-row-compare');
        if (editorLabel) editorLabel.style.display = 'block';
        // Sync heights: ì˜¤ë¥¸ìª½(textarea ë˜ëŠ” highlight)ê³¼ ì™¼ìª½(source) ì¤‘ í° ìª½ì— ë§ì¶¤
        requestAnimationFrame(() => {
            const sourceText = panel.querySelector('.source-text');
            const sourceH = sourceText ? sourceText.scrollHeight : 0;
            const isHighlight = hlDiv && hlDiv.style.display !== 'none';
            const rightEl = isHighlight ? hlDiv : ta;
            // ì˜¤ë¥¸ìª½ì´ hiddenì´ë©´ ì„ì‹œë¡œ ë³´ì´ê²Œ í•´ì„œ ì¸¡ì •
            const wasHidden = rightEl.style.display === 'none';
            if (wasHidden) { rightEl.style.display = ''; rightEl.style.visibility = 'hidden'; }
            const editorH = rightEl.scrollHeight;
            if (wasHidden) { rightEl.style.display = 'none'; rightEl.style.visibility = ''; }
            const maxH = Math.max(300, sourceH, editorH);
            if (!isHighlight && ta) ta.style.height = maxH + 'px';
            if (isHighlight && hlDiv) hlDiv.style.height = maxH + 'px';
            if (sourceText) sourceText.style.height = maxH + 'px';
        });
    }

    function escapeHtml(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
    }

    // Close modal on outside click
    document.getElementById('result-modal').addEventListener('click', function (e) {
        // ì¶”ì¶œ/ë§¤ë‰´ì–¼ë¼ì´ì¦ˆ ì§„í–‰ ì¤‘ì´ë©´ ë°°ê²½ í´ë¦­ìœ¼ë¡œ ë‹«ì§€ ì•ŠìŒ
        if (e.target === this && !document.getElementById('extract-header')?.querySelector('.spinner') && !document.getElementById('manualize-status')?.offsetParent) closeModal();
    });
</script>

<style>
    .modal {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.5);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 1000;
    }

    .modal-content {
        background: white;
        padding: 2rem;
        border-radius: 8px;
        max-width: 600px;
        width: 90%;
        max-height: 80vh;
        overflow: auto;
    }

    .rag-check {
        display: inline-block;
        margin-left: 4px;
        color: #10b981;
        font-weight: bold;
        font-size: 14px;
        vertical-align: middle;
        title: "RAG ë°ì´í„°í™” ì™„ë£Œ";
    }

    .editor-modal-content {
        display: flex;
        flex-direction: column;
        max-height: 90vh;
        overflow: hidden;
        padding: 0;
    }

    .editor-header {
        padding: 1.5rem 2rem 0.5rem;
        border-bottom: 1px solid #e5e7eb;
        flex-shrink: 0;
    }

    .editor-header h3 {
        margin-top: 0;
    }

    .manualize-lamp {
        font-size: 13px;
        font-weight: 600;
        color: #8b5cf6;
        padding: 3px 12px;
        border-radius: 12px;
        background: #f5f3ff;
        animation: lamp-pulse 1.8s ease-in-out infinite;
    }

    @keyframes lamp-pulse {
        0%, 100% { opacity: 0.4; }
        50% { opacity: 1; }
    }

    @keyframes badge-blink {
        0%, 100% { opacity: 1; }
        50% { opacity: 0.3; }
    }

    .badge-working {
        animation: badge-blink 1s ease-in-out infinite;
    }

    .editor-body {
        flex: 1;
        overflow-y: auto;
        padding: 1.5rem 2rem;
        display: flex;
        flex-direction: column;
        gap: 1.5rem;
    }

    .editor-footer {
        padding: 1rem 2rem;
        border-top: 1px solid #e5e7eb;
        display: flex;
        justify-content: flex-end;
        gap: 0.5rem;
        flex-shrink: 0;
    }

    .modal-content h3 {
        margin-top: 0;
    }

    .modal-content pre {
        background: #f5f5f5;
        padding: 1rem;
        border-radius: 4px;
        overflow: auto;
        white-space: pre-wrap;
        word-break: break-word;
    }

    .close {
        float: right;
        font-size: 1.5rem;
        cursor: pointer;
    }

    .actions-cell {
        white-space: nowrap;
    }

    .actions-cell button {
        margin: 2px;
    }

    .btn-extract {
        background: #6366f1;
    }

    .btn-manualize {
        background: #8b5cf6;
    }

    .btn-view-manual {
        background: #3b82f6;
    }

    .btn-gate {
        background: #f59e0b;
    }

    .btn-approve {
        background: #10b981;
    }

    .text-muted {
        color: #9ca3af;
    }

    /* Auto-expand textareas */
    .editor-textarea {
        width: 100%;
        min-height: 80px;
        padding: 10px;
        border-radius: 6px;
        border: 1px solid #d1d5db;
        font-family: inherit;
        font-size: 14px;
        resize: vertical;
        overflow: hidden;
        line-height: 1.6;
        box-sizing: border-box;
    }
    .highlight-preview {
        width: 100%;
        min-height: 80px;
        padding: 10px;
        border-radius: 6px;
        border: 1px solid #f59e0b;
        background: #fffbeb;
        font-size: 14px;
        line-height: 1.6;
        box-sizing: border-box;
        overflow-y: auto;
    }

    .gate-popover {
        position: absolute;
        z-index: 1000;
        max-width: 360px;
        min-width: 240px;
        background: #fff;
        border: 1px solid #e5e7eb;
        border-radius: 8px;
        box-shadow: 0 8px 24px rgba(0,0,0,0.15);
        padding: 12px 14px;
        font-size: 13px;
        line-height: 1.5;
        display: none;
    }
    .gate-popover-arrow {
        position: absolute;
        width: 10px;
        height: 10px;
        background: #fff;
        border: 1px solid #e5e7eb;
        transform: rotate(45deg);
    }
    .gate-popover-arrow.arrow-top {
        top: -6px;
        border-bottom: none;
        border-right: none;
    }
    .gate-popover-arrow.arrow-bottom {
        bottom: -6px;
        border-top: none;
        border-left: none;
    }
    .gate-mark:hover {
        outline: 2px solid #f59e0b;
        outline-offset: 1px;
    }

    /* Comparison modal styles */
    .compare-container {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 1rem;
    }

    .compare-panel {
        display: flex;
        flex-direction: column;
    }

    .compare-label {
        font-weight: 600;
        font-size: 0.9rem;
        margin-bottom: 0.5rem;
        padding: 6px 12px;
        border-radius: 6px 6px 0 0;
    }

    .compare-panel:first-child .compare-label {
        background: #fef2f2;
        color: #991b1b;
    }

    .compare-panel:last-child .compare-label {
        background: #f0fdf4;
        color: #166534;
    }

    .compare-text {
        background: #fafafa;
        border: 1px solid #e5e7eb;
        border-radius: 0 0 6px 6px;
        padding: 12px;
        font-size: 14px;
        line-height: 1.6;
        white-space: pre-wrap;
        word-break: break-word;
        flex: 1;
        color: #374151;
        min-height: 350px;
        max-height: 60vh;
        overflow-y: auto;
    }

    .compare-textarea {
        border: 1px solid #86efac;
        border-radius: 0 0 6px 6px;
        padding: 12px;
        font-size: 14px;
        line-height: 1.6;
        font-family: inherit;
        resize: vertical;
        min-height: 350px;
        max-height: 60vh;
        flex: 1;
        box-sizing: border-box;
    }

    .compare-textarea:focus {
        outline: none;
        border-color: #22c55e;
        box-shadow: 0 0 0 3px rgba(34, 197, 94, 0.15);
    }

    .section-row {
        display: flex;
        gap: 1rem;
    }

    .section-row-compare .source-panel {
        flex: 1 1 50%;
        min-width: 0;
    }

    .section-row-compare .editor-panel {
        flex: 1 1 50%;
        min-width: 0;
    }

    .section-row-compare .editor-textarea {
        min-height: 300px;
    }

    .editor-panel {
        flex: 1;
        min-width: 0;
    }

    .evidence-panel {
        background: #f5f3ff;
        border: 1px solid #ddd6fe;
        border-radius: 6px;
        padding: 8px 12px;
        margin-bottom: 8px;
        max-height: 200px;
        overflow-y: auto;
    }

    .source-panel {
        display: none;
    }

    .column-label {
        font-weight: 600;
        font-size: 12px;
        color: #6b7280;
        margin-bottom: 4px;
        padding: 0 2px;
    }

    .source-text {
        background: #f9fafb;
        border: 1px solid #e5e7eb;
        border-radius: 6px;
        padding: 10px;
        font-size: 13px;
        line-height: 1.6;
        white-space: pre-wrap;
        word-break: break-word;
        overflow-y: auto;
        color: #374151;
        box-sizing: border-box;
    }

    @media (max-width: 768px) {
        .compare-container {
            grid-template-columns: 1fr;
        }
    }
</style>
{% endblock %}