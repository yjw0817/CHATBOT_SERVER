# [DEMO BUILD PROMPT] Argos Apartment AI – Sales-led RAG Builder Demo (Due: Fri)

## 0) Mission (do not overbuild)
Build a demo system that proves:
1) Sales can upload apartment-specific agreements (Word/PDF) and the system transforms them into a high-quality manual (standard template).
2) The system enforces document quality via a “Quality Gate” (missing/ambiguous/conflicting/PII/API-needed checks).
3) The knowledge base supports RAG with citations (doc/section/snippet).
4) Chat usage is logged and automatically produces improvement suggestions.
5) One-click patch: approve a suggestion → update the knowledge base → reindex → answer improves on retry.
6) Extract API requirements from uploaded docs: intents → API spec table + JSON/YAML export.
7) Legacy VB6 integration concept: no sockets needed; REST request/response with conversation_id (show protocol + optional poll endpoint).

Constraints:
- Single developer.
- Must be stable for demo by Friday.
- Do NOT implement actual “execute actions” (booking/send SMS). Only preview/queue stub.
- Avoid unnecessary features. Focus on the full workflow loop (Upload → Gate → Index → Chat → Suggest → Patch → Reindex).

Deliverable:
- A local runnable web app (or minimal UI) with 4 screens:
  A) Upload & Manualize
  B) Quality Gate
  C) Chat (with citations)
  D) Improvement Queue + API Spec Extractor

Tech stack: choose simplest (Node+Express+SQLite + simple HTML, or Python FastAPI+SQLite, etc.)
No need to integrate into existing VB6. Only show REST protocol sample.

---

## 1) Demo Script (must support this end-to-end)
### Demo A: Sales doc → Manual → Gate → RAG
1) Upload “Apt A rules.docx” (or PDF).
2) System generates “Manual v1” with standard sections.
3) Quality Gate shows issues (Red/Yellow) with suggested fixes.
4) Approve (developer checks only red issues) → index into RAG.
5) Ask chat: “Refund policy?” → answer with citations.

### Demo B: Chat logs → suggestions → one-click patch
6) Ask a question that currently has weak answer (or missing).
7) System logs conversation and flags “low confidence / missing citation”.
8) Improvement Queue shows suggestion item.
9) Click suggestion → generate patch text + target section.
10) Approve patch → update manual → reindex.
11) Ask same question → improved answer with citations.

### Demo C: API requirements extraction
12) Open API Spec Extractor tab → show intents + API skeleton.
13) Export JSON/YAML.

---

## 2) Data Model (SQLite recommended)
Implement these tables (minimum fields):

### apartments
- apt_id TEXT PK
- name TEXT
- created_at DATETIME

### documents
- doc_id TEXT PK
- apt_id TEXT FK
- title TEXT
- source_filename TEXT
- source_type TEXT (docx/pdf/text)
- content_hash TEXT
- version INTEGER
- status TEXT (DRAFT/APPROVED/ARCHIVED)
- created_at DATETIME
- updated_at DATETIME

### manual_sections
- section_id TEXT PK
- doc_id TEXT FK
- section_name TEXT  (e.g. 운영시간, 예약, 강좌, 환불, 공지/문자, 예외/문의)
- section_text TEXT

### qa_issues
- issue_id TEXT PK
- doc_id TEXT FK
- severity TEXT (RED/YELLOW)
- issue_type TEXT (MISSING/AMBIGUOUS/CONFLICT/PII_RISK/API_NEEDED)
- message TEXT
- suggestion TEXT
- status TEXT (OPEN/RESOLVED/WAIVED)

### chunks (for RAG)
- chunk_id TEXT PK
- doc_id TEXT FK
- section_name TEXT
- chunk_index INTEGER
- chunk_text TEXT
- embedding BLOB/TEXT optional (for demo can skip real embedding and use keyword search)
- created_at DATETIME

### conversations
- conversation_id TEXT PK
- apt_id TEXT
- client_id TEXT
- created_at DATETIME
- last_at DATETIME

### messages
- msg_id TEXT PK
- conversation_id TEXT FK
- role TEXT (user/assistant/system)
- text TEXT
- meta_json TEXT
- created_at DATETIME

### improve_suggestions
- sug_id TEXT PK
- apt_id TEXT
- title TEXT
- reason TEXT
- proposed_patch TEXT
- target_doc_id TEXT
- target_section_name TEXT
- status TEXT (PENDING/APPROVED/APPLIED/REJECTED)
- created_at DATETIME
- updated_at DATETIME

### api_specs
- spec_id TEXT PK
- doc_id TEXT FK
- intent TEXT
- endpoint TEXT
- method TEXT
- req_fields_json TEXT
- resp_fields_json TEXT
- auth TEXT
- errors_json TEXT
- created_at DATETIME

---

## 3) Core Services (implement minimal but real)
### 3.1 Document Upload + Text Extraction
Endpoints:
- POST /api/upload (multipart: apt_id, file)
  - Extract text (docx preferred; pdf basic text)
  - Compute hash
  - If same hash exists for same apt: increment version & replace content (or mark old as archived and new as latest)
  - Save in documents

### 3.2 Manualization (AI-assisted)
Endpoint:
- POST /api/doc/:doc_id/manualize
  - Use LLM prompt to convert raw doc text into standard manual sections (6 sections):
    1) 운영시간/휴무
    2) 예약/취소/변경
    3) 강좌/정원/대기
    4) 환불/위약/정산
    5) 공지/문자 발송 규칙
    6) 예외/문의/권한
  - Store to manual_sections
  - Set doc status DRAFT

### 3.3 Quality Gate
Endpoint:
- POST /api/doc/:doc_id/quality-gate
  - Run checks via LLM prompt + some simple rules:
    - Missing required sections or missing critical fields (e.g., refund deadline, reservation cancellation fee)
    - Ambiguous phrases: “적당히”, “가능하면”, “상황에 따라” etc.
    - Conflicts: two statements that contradict within same topic
    - PII risk: phone numbers, 주민번호 patterns etc.
    - API needed: statements implying system actions (create reservation, modify class, send sms)
  - Output list of issues with severity RED/YELLOW and suggestions
  - Save to qa_issues

Approval:
- POST /api/doc/:doc_id/approve
  - Allowed only if no RED issues open (or allow override with reason)
  - Sets doc status APPROVED
  - Triggers indexing

### 3.4 Indexing for RAG
Endpoint:
- POST /api/doc/:doc_id/reindex
  - Chunk manual sections with overlap (e.g., 400-600 chars chunks, 100 chars overlap)
  - Store into chunks
  - For demo, implement retrieval by:
    - keyword scoring (BM25-like simple) OR
    - embedding if easy (optional)
  - Return count of chunks

### 3.5 Chat with Citations
Endpoint:
- POST /api/chat
Request JSON:
{
  "apt_id": "APT001",
  "client_id": "PC-12",
  "conversation_id": null or "c_...",
  "message": "환불 규정 알려줘"
}
Behavior:
- If no conversation_id: create new.
- Retrieve top-k relevant chunks for the question.
- Generate answer using LLM, MUST include:
  - reply_text (concise)
  - citations: [{doc_title, section_name, snippet}]
  - next_question if needed (ask only one)
  - confidence flag (HIGH/MED/LOW)
- Save messages with meta_json containing citations/confidence.

Response JSON:
{
  "conversation_id":"c_...",
  "reply_text":"...",
  "citations":[...],
  "next_question":null,
  "confidence":"MED",
  "actions":[]
}

Rules:
- If retrieval is weak or no chunks: respond conservatively and set confidence LOW.
- Always show citations if confidence != LOW.

### 3.6 Improvement Suggestions (from chat logs)
Endpoint:
- POST /api/improvements/generate?apt_id=APT001
Logic:
- Analyze recent messages (last N) for:
  - LOW confidence
  - user re-asks similar question
  - missing citations
- Create top 5 suggestions:
  - title: “Add FAQ about refund deadline”
  - reason: “Repeated question, low confidence, missing policy text”
  - proposed_patch: text to insert
  - target_section_name
Save to improve_suggestions status PENDING.

One-click patch:
- POST /api/improvements/:sug_id/apply
  - Generate final patch (LLM) if proposed_patch empty OR use existing proposed_patch
  - Append/update manual_sections (target section)
  - Mark suggestion APPLIED
  - Reindex doc

### 3.7 API Spec Extractor
Endpoint:
- POST /api/doc/:doc_id/extract-api-spec
Behavior:
- Use LLM to extract intents and produce API spec rows:
  - intent
  - endpoint (suggested)
  - method
  - req fields
  - resp fields
  - auth/roles
  - error cases
Store to api_specs.
Export:
- GET /api/doc/:doc_id/api-spec/export?format=json|yaml

---

## 4) UI Requirements (simple is fine)
Create minimal web UI (no heavy frontend required):
### Screen A: Upload & Manualize
- Select apartment (dropdown) + create new apt
- Upload file
- Show doc list with version and status
- Buttons: Manualize, Quality Gate, Approve, Reindex

### Screen B: Quality Gate
- List issues grouped by severity (RED/YELLOW)
- Each issue shows suggestion
- Buttons: mark resolved / waive (optional)
- Approve button disabled if RED open

### Screen C: Chat
- Apartment selector
- Chat box
- Show assistant reply + citations (doc/section/snippet)
- Show confidence badge

### Screen D: Improvements + API Spec
- Improvements tab: list suggestions, apply button
- API Spec tab: show table + export buttons

---

## 5) Prompts (implement as constants)
Provide 4 prompt templates in code:

### P1 Manualization Prompt (Korean)
Input: raw_text
Output: JSON with 6 sections keys exactly.
- Must keep content accurate, no invention.
- Use bullet points where possible.
- Normalize terminology, add definitions.

### P2 Quality Gate Prompt
Input: manual JSON
Output: JSON list of issues {severity, type, message, suggestion}
- Must detect missing/ambiguous/conflict/pii/api_needed

### P3 Chat Answer Prompt
Input: question + top chunks
Output: JSON {reply_text, citations[], next_question, confidence}
- reply concise
- cite 1-2 snippets
- if insufficient evidence -> LOW + ask one question

### P4 Improvement Patch Prompt
Input: suggestion + target section + relevant chat examples
Output: patch text that can be appended into manual, and a short rationale.

---

## 6) Non-goals (avoid scope creep)
- No real booking creation in VB6.
- No SMS vendor integration.
- No socket server.
- No advanced auth (simple token is ok).
- No multi-tenant complexity beyond apartment_id.

---

## 7) Must-have Demo Data
Include sample demo files or seed data:
- APT001
- One doc: “A아파트 운영 규칙 v1”
- Optional second doc: “A아파트 운영 규칙 v2” to show update/overwrite
Seed a few Q&A examples.

---

## 8) Acceptance Criteria (strict)
By Friday:
1) Upload → manualize → gate → approve → reindex works.
2) Chat returns answer with citations for at least 3 questions.
3) Generate improvements from logs produces at least 3 suggestions.
4) Apply suggestion updates KB and changes answer for same question.
5) API spec extraction outputs a table and exports JSON or YAML.
6) Provide REST protocol snippet showing VB6 integration with conversation_id.

---

## 9) Implementation Steps (suggested order)
1) Bootstrap server + SQLite + basic UI
2) Upload + store raw text + doc versions
3) Manualization using LLM → store sections
4) Quality Gate → store issues + approve logic
5) Chunking + retrieval (keyword)
6) Chat + citations + logging
7) Improvements generator + apply patch + reindex
8) API spec extractor + export
9) Polish UI, add demo script shortcuts & seeded doc

---

## 10) Output
Return:
- repo structure
- run instructions (one command)
- sample .env fields (LLM API key)
- screenshots optional
