요청: Manualize → flatten(section_text 저장) → Gate(검증) → Fill(보강) → Gate → Publish(RAG 반영) 파이프라인을 구현/정리해줘.
현재 DB 저장은 manual_sections.section_text(plain text)만 사용 중이며, fill은 덮어쓰기 구조임.

1) 사용 프롬프트(그대로 적용)
- MANUALIZE_PROMPT_V3: (아래 코드블록 그대로)
- GATE_CHECK_PROMPT_V1: (아래 코드블록 그대로)
- FILL_SECTION_TEXT_PROMPT_V2: (아래 코드블록 그대로)
(필요하면 FINALIZE_SECTION_TEXT_PROMPT_V1은 옵션으로만)

2) 현재 데이터 흐름/제약(중요)
- Manualize는 JSON으로 받지만, DB에는 JSON 저장 안 하고 파서가 flatten해서 section_text로 저장.
- Fill은 기존 section_text를 LLM이 제안한 plain text로 교체(덮어쓰기).
- 버전/히스토리 없음(당장은 유지 가능하나, 최소한의 안전장치 제안도 함께 해줘).

3) 구현해야 할 핵심 로직(필수)
A. Manualize 단계
- 입력: raw_text
- LLM 호출: MANUALIZE_PROMPT_V3 → manualize_json 응답
- 서버 파서가 manualize_json.sections[].content를 flatten해서 section_text 생성
- DB 저장: manual_sections(section_name, section_text, doc_id, updated_at...)

B. Gate 단계(최소 2회)
- Gate#1: Manualize 후 section_text 생성 직후, 섹션별로 GATE_CHECK_PROMPT_V1 호출
  - 결과 status=BLOCK이면 해당 섹션은 "RAG 반영 금지" 상태 표시
  - status=NEED_FIX이면 "보강 필요" 상태 표시
  - status=PASS이면 통과
- Gate#2: Fill 적용 후(사용자 '적용하기' 직전 또는 직후), 동일하게 Gate 재검증
  - PASS가 아니면 Publish(반영) 막기

C. Fill 단계
- 입력: (현재) section_text + raw_text(최대 4000자)
- LLM 호출: FILL_SECTION_TEXT_PROMPT_V2
- 출력: improved_section_text(plain text)
- UI: diff 모달 → 적용하기 → textarea 교체 → saveEditor() → PUT /api/doc/{doc_id}/sections
- DB: manual_sections.section_text 덮어쓰기

4) 출력 포맷 강제(중요)
- section_text 포맷 규칙:
  - 섹션은 "## "로 시작
  - 항목은 "### "로 시작
  - 본문은 "-" bullet
  - Q/A는 있을 때만:
    - Q: ...
    - A: ...
- Gate는 JSON만 반환(PASS/NEED_FIX/BLOCK + reasons[] + score)

5) 반드시 추가로 구현해줘야 하는 것(운영 안정성)
- PII 마스킹 유지/검증: Gate에서 PII 패턴(전화/이메일/계좌/주소/식별번호) 탐지 후 미마스킹이면 BLOCK
- hallucination 방지: Gate에서 raw_text 대비 근거 없는 수치/기간/금액이 섞이면 NEED_FIX 또는 BLOCK
- 문서 raw_text는 최대 4000자로 잘릴 수 있으므로:
  - 가능하면 manualize_json의 source_quotes를 기반으로 섹션별 관련 원문 일부(raw_evidence)를 추출해 Fill/Gate에 추가 전달하는 개선안도 제안해줘.

6) (선택이지만 강력 추천) 최소 히스토리/롤백 설계
- 지금은 덮어쓰기지만, 최소한 update 전 텍스트를 남겨 롤백 가능하게:
  - 옵션1: manual_sections에 prev_section_text 컬럼 1개(최근 1개만)
  - 옵션2: manual_section_revisions 테이블(append-only)
- SQLite로 먼저 구현하고, MariaDB로 옮길 때 스키마/쿼리 변경 최소화되게 설계

7) Claude Code에게 산출물 요구
- 서버측: LLM 호출 함수 시그니처/입출력, Gate 판단 로직, flatten 파서(Manualize JSON → section_text), DB 업데이트 트랜잭션 흐름
- API: /api/doc/{doc_id}/manualize, /api/doc/{doc_id}/sections, /api/doc/{doc_id}/sections/{section}/fill, /api/doc/{doc_id}/sections/{section}/gate (예시로 제안 가능)
- 프론트: 상태 배지(PASS/NEED_FIX/BLOCK), Fill diff 모달 적용 흐름, Publish 버튼 활성/비활성 조건
- 테스트: 샘플 raw_text 1개 기준, Gate BLOCK/NEED_FIX/PASS 케이스 테스트 전략

아래는 프롬프트 전문:
[MANUALIZE_PROMPT_V3]
...여기에 코드블록 그대로 붙여넣기...

[GATE_CHECK_PROMPT_V1]
...여기에 코드블록 그대로 붙여넣기...

[FILL_SECTION_TEXT_PROMPT_V2]
...여기에 코드블록 그대로 붙여넣기...
