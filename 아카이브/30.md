✅ 문서 단위 자동 처리 스펙 (Gate / 맥락보강 / RAG최적화)
0) 목표

섹션 분할 구조는 유지하되, 사용자는 문서에서 버튼을 “한 번만” 눌러도 되도록 한다.

내부적으로는 서버/프론트가 섹션을 순차 처리하여 저장/검증/반영을 자동 수행한다.

비용/속도 최적화를 위해 기본은 NEED_FIX 섹션만 자동 처리한다.

1) 화면/버튼 구성 (문서 상세 화면 기준)
필수 버튼 3개

Gate (문서 전체)

🔧 문서 전체 보강 (맥락 보강/Fill)

📦 RAG 반영 (문서 전체 RAG최적화+반영)

섹션별 버튼 정책

섹션별 Gate/Fill/RAG최적화 버튼은 유지하되:

기본 UI에서는 숨김(“고급/더보기” 아래)

운영/디버깅/예외 처리용으로만 사용

2) 상태 모델 (섹션 단위)

각 섹션은 아래 상태를 가진다:

gate_status: PASS | NEED_FIX | BLOCK | NONE

fill_status: NOT_RUN | RUNNING | APPLIED | SKIPPED | FAILED

rag_status: NOT_READY | READY | PUBLISHED | FAILED

UI 힌트 규칙(기존 규칙 유지)

PASS: “✅ RAG 반영 가능”

NEED_FIX: “🔧 보강 → Gate 재검증”

BLOCK: “⛔ 수동 수정 필요”

Gate 결과 수신 시 즉시 갱신

3) 문서 단위 “Gate 전체” 동작
트리거

사용자가 문서 화면에서 Gate(문서 전체) 클릭

처리

서버는 문서의 모든 섹션을 대상으로 Gate를 순차 또는 제한 병렬(권장: 순차) 실행

섹션별 gate_status 갱신

문서 요약 상태도 함께 갱신:

doc_gate_summary: PASS n개 / NEED_FIX n개 / BLOCK n개

완료 조건

모든 섹션에 gate_status != NONE가 되면 완료

4) 문서 단위 “🔧 문서 전체 보강(Fill)” 동작 (핵심)
목표

사용자는 한 번 클릭만.
내부적으로는 NEED_FIX 섹션만 자동 보강 → 저장 → Gate 재검증까지 자동.

활성 조건

문서에 gate_status=NEED_FIX 섹션이 1개 이상일 때만 활성

gate_status가 아직 없으면:

UX 옵션 A(권장): “먼저 Gate를 실행하세요” 안내 후 중단

UX 옵션 B: 자동으로 Gate 전체 실행 후 이어서 Fill 진행

대상 섹션 선택 규칙 (기본)

기본: gate_status == NEED_FIX 인 섹션만

옵션(토글, 기본 OFF): PASS도 “표현 정돈 수준”으로 보강 실행

실행 순서 (순차 강제)

섹션 i에 대해:

fill_status = RUNNING

Fill(맥락보강) 실행 (프롬프트/로직은 기존 그대로)

결과 비교(기존 diff 모달 방식 유지)

사용자가 선택:

적용(Apply):

섹션 저장(save)

Gate 재검증(Gate#2) 실행

fill_status = APPLIED

건너뛰기(Skip):

fill_status = SKIPPED

다음 섹션으로 진행

저장 모드 (필수: A만, 옵션: B 추가 가능)

A) 섹션별 즉시 저장 (기본/권장)

Apply 선택 시 섹션 즉시 저장 → Gate#2 → 다음

B) 일괄 저장 (옵션)

모든 Apply 결과를 메모리에 모아두고 마지막에 한 번에 저장

중간 실패 리스크가 크므로 기본 OFF

실패 처리

특정 섹션에서 Fill 또는 저장 또는 Gate#2 실패 시:

해당 섹션 fill_status=FAILED

에러 메시지 기록(로그/DB)

전체 프로세스는 중단하지 말고 다음 섹션 계속

완료 후 “실패 섹션 리스트/사유” 요약 표시

진행 UI

상단 진행 표시: 보강 중: {done}/{total_target} + 경과시간

섹션 배지/힌트는 단계마다 즉시 갱신

5) 문서 단위 “📦 RAG 반영(최적화+반영)” 동작
목표

사용자 1회 클릭으로 문서 전체를 반영하되, 정책상 PASS만 반영.

반영 대상 규칙

gate_status == PASS 인 섹션만

NEED_FIX/BLOCK은 절대 반영 금지

(옵션) “PASS 중에서도 특정 조건 불충족 시 제외” 같은 기존 정책이 있으면 유지

처리

서버는 PASS 섹션만 대상으로 RAG최적화/인덱싱/업서트 수행(기존 로직 그대로)

문서 요약 상태 갱신:

published_count, skipped_count, failed_count

UI 결과

“반영 완료: PASS n개 / 실패 n개 / 제외 n개(NEED_FIX/BLOCK)” 요약 표시

6) API/엔드포인트 요구사항(변경/추가 최소)
기존 섹션 단위 API가 있다면 재사용

Gate 섹션 실행 API

Fill 섹션 실행 API

섹션 저장 API

RAG 반영/최적화 API

추가(권장) 문서 단위 오케스트레이션 API

프론트가 루프를 돌며 섹션 API를 호출해도 되지만(구현 쉬움),
운영 안정성을 위해 문서 단위 오케스트레이션 API를 권장.

권장 3개:

POST /doc/{doc_id}/gate-all

POST /doc/{doc_id}/fill-all (내부적으로 NEED_FIX만 순차 처리)

POST /doc/{doc_id}/publish-all (PASS만)

응답에는 최소:

실행 요약(대상 수/성공 수/실패 수)

실패 섹션 목록(섹션 id + reason)

최신 문서 상태 요약

7) 비용/속도 정책(강제)

Fill은 기본적으로 NEED_FIX 섹션만

Gate#2는 Apply된 섹션만

Publish는 PASS 섹션만

자동 병렬 실행은 금지(순차 기본). 필요 시 “동시 2개” 같은 제한형만 허용

8) 완료 조건/정합성 체크

Gate-all 완료 후: 모든 섹션에 gate_status가 있어야 함

Fill-all 완료 후: 대상 섹션 모두 fill_status in (APPLIED, SKIPPED, FAILED) 이어야 함

Publish-all 완료 후: PASS 섹션 중 성공/실패가 집계되어야 함



정정내용:

1) 상태 모델 3개는 “필수 아님” (특히 fill_status / rag_status)

네가 말했던 대로 새로운 상태 모델을 늘리면 혼동/마이그레이션/버그 포인트가 늘어남.

권장 최소화(운영 안전):

gate_status는 공식 상태로 유지 (PASS/NEED_FIX/BLOCK/NONE)

fill_status, rag_status는 DB 컬럼으로 만들지 말고

“마지막 실행 결과”를 task_log / run_log(실행 로그) 에만 남겨도 충분함

UI에서 필요하면 “최근 실행 결과”를 보여주면 됨

✅ 결론: gate_status만 ‘상태’로 고정하고, 나머지는 실행 로그/최근 결과로 처리하는 게 더 낫다.

2) Fill-all 실행 전제: “Gate가 없으면 자동 Gate”는 B만 남겨

너 스펙에 UX 옵션 A/B가 있는데, 운영에선 A가 불편하고 결국 B로 간다.

Fill-all 눌렀는데 “Gate부터 하세요”는 사용자 입장에서 다시 클릭해야 해서 UX 최악

게다가 “문서 단위 1클릭” 목표랑 충돌

✅ 따라서 정책을 하나로 고정:

Fill-all 클릭 → 내부에서 Gate-all 먼저 실행 → NEED_FIX만 Fill 순차 실행

(즉 A 제거, B 고정)

3) Fill-all은 “diff 모달을 섹션마다” 띄우면 다시 일이 많아짐

너도 말했듯 섹션별 처리 자체가 일이 많아지는 게 문제인데,
섹션마다 모달 뜨면 또 사람 손이 계속 들어가.

✅ 여기서 선택지를 2단으로 바꾸는 게 현실적이야:

기본 모드(권장): 자동 적용(Apply 자동)

단, Gate#2에서 PASS/NEED_FIX 결과로 안전장치

고급 모드(더보기): 섹션별 diff 확인 모드(지금 방식 유지)

즉,

“문서 전체 보강”은 기본은 무인 자동

예외/디버깅만 수동 diff

4) Publish-all에서 “RAG최적화 버튼이 섹션별인데 합쳐지는 문제” 해결 문장 필요

지금 현상이:

섹션별 최적화인데 누르면 전체가 하나로 합쳐짐

이건 스펙에서 출력 단위를 못 박아야 해결돼.

✅ 스펙에 한 줄 추가하면 됨:

RAG 최적화 결과는 “섹션 단위 산출물”로 유지하며, UI 표시를 위해 합쳐 보여줄 수는 있어도 저장/업서트 단위는 섹션이다.

(즉 “보기만 합치고, 데이터는 섹션 단위로 저장/업서트”)

결론 :

gate_status만 공식 상태로 유지(나머지는 실행 로그), Fill-all은 Gate-all 자동 포함, Fill-all 기본은 자동 적용(수동 diff는 더보기), Publish-all은 섹션 단위 업서트(표시는 합쳐도 됨).
