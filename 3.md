# STEP 3 구현 지시 — Chat (RAG + citations) + Improvements + One-click Patch + API Spec (SQLite 유지)

Step2까지 완료됨:
- documents.status=APPROVED
- chunks 생성됨(키워드 검색용)
이제 Step3를 구현한다.

========================
0) 공통 규칙(절대)
========================
- RAG 검색은 APPROVED 문서의 chunks만 사용한다.
- citations가 없으면 확정 답변 금지: confidence=LOW + follow-up 질문 1개만.
- LLM 응답은 항상 "JSON 스키마"로 강제한다(파싱 실패 방지).
- 예약 생성/문자 발송 같은 액션은 데모에서 실행 금지(actions=[]).

========================
1) /api/chat 구현
========================
Endpoint:
POST /api/chat

Request:
{
  "apt_id": "APT001",
  "client_id": "PC-01",
  "conversation_id": null,
  "message": "환불 규정 알려줘"
}

Server Flow:
1) conversation_id 없으면 conversations에 생성하고 id 반환
2) messages에 user 메시지 저장
3) Retrieval:
   - 해당 apt_id의 APPROVED docs에 연결된 chunks만 검색
   - 키워드 기반 score로 top_k=5 선택
   - 결과 0개면: confidence LOW + "근거 부족" 안내 + 질문 1개(next_question) 반환
4) LLM prompt:
   - context로 top_k chunks의 (section_name + chunk_text + doc_title) 전달
   - 반드시 아래 JSON으로만 응답하도록 강제:

LLM Response JSON Schema:
{
  "reply_text": "string",
  "citations": [
    {"doc_id":"...", "doc_title":"...", "section_name":"...", "snippet":"..."}
  ],
  "confidence": "HIGH|MED|LOW",
  "next_question": "string|null",
  "actions": []
}

5) messages에 assistant 답변 저장(meta_json에 citations, confidence, retrieval_score 저장)
6) Response:
{
  "conversation_id": "...",
  "reply_text": "...",
  "citations": [...],
  "confidence": "...",
  "next_question": null,
  "actions": []
}

Notes:
- snippet은 chunk_text 전체가 아니라 120~200자 정도로 잘라 저장/표시.
- citations는 최소 1개 이상(가능할 때). 없으면 LOW 처리.

========================
2) Chat UI 연결
========================
- templates/chat.html에서:
  - apt 선택(간단히 텍스트 입력 또는 드롭다운)
  - 메시지 입력
  - 응답 텍스트 + confidence 배지 표시
  - citations 리스트(문서명/섹션/스니펫)

========================
3) Improvements 생성
========================
Endpoint:
POST /api/improvements/generate?apt_id=APT001

Logic(간단):
- 최근 messages 중 assistant 답변에서
  - confidence=LOW 또는 citations 비어있음
  - 또는 같은 키워드가 반복된 질문(간단 유사도: 공백 분리 키워드 교집합 비율)
- TOP 5 제안을 improve_suggestions 테이블에 PENDING으로 저장

Suggestion 구조 예:
- title: "환불 규정 명확화 필요"
- reason: "모호/근거 부족/반복 질문"
- target_section_name: "환불/위약/정산" (또는 적절한 섹션)
- patch_intent: "FAQ 추가" / "문장 명확화"
- status: PENDING

Return:
{success:true, count: N}

UI:
- templates/improvements.html에 "Generate" 버튼 + 제안 리스트 표시

========================
4) One-click Patch 적용
========================
Endpoint:
POST /api/improvements/{sug_id}/apply

Flow:
1) suggestion 조회 + 관련 대화 로그 일부(해당 apt_id의 유사 질문/LOW 답변)
2) LLM으로 "패치 문단" 생성 (없는 규정은 만들지 말고, '확인 필요' 형태 허용)
3) target_section_name에 해당하는 manual_sections.section_text에 append:
   - 구분선 + "FAQ" 블록 추가(질문/답)
4) suggestion.status=APPLIED
5) 해당 doc_id에 대해 reindex 자동 실행(즉시 chunks 갱신)
6) return: {success:true, reindexed:true}

Important:
- 패치는 "추정 규정 생성 금지".
- 문서에 없는 내용이면 "확인 필요"로 남기거나 "관리자 확정 필요"로 작성.

UI:
- improvements.html에 Apply 버튼
- Apply 후 "Applied + Reindexed" 표시

========================
5) API Spec 추출(데모)
========================
Endpoint:
POST /api/doc/{doc_id}/extract-api-spec

Input:
- manual_sections 6개 전체 + quality issues(API_NEEDED 포함)

Output:
- api_specs 테이블에 저장(JSON TEXT)
- 최소 포함 필드:
  - intent_name
  - endpoint (예: /api/booking/create)
  - method
  - request_fields[]
  - response_fields[]
  - auth (관리자/입주민/내부)
  - notes

Export:
GET /api/doc/{doc_id}/api-spec/export?format=json|yaml

UI:
- improvements.html에서 "API Spec" 영역에 테이블 표시 + Export 버튼

========================
6) Acceptance (반드시 만족)
========================
1) 채팅 질문 3개에 citations 포함 답변
2) 근거 없으면 LOW + next_question 1개
3) improvements generate로 3개 이상 생성 가능
4) apply 1개 실행 후 reindex 되고,
   동일 질문 재시도 시 citations/답변이 개선되는 것이 보일 것
5) api spec 표 출력 + json export 동작

========================
7) 구현 산출물
========================
- 수정된 파일 목록
- 실행 방법 그대로(uvicorn)
- 테스트 시나리오(버튼/엔드포인트 순서)
